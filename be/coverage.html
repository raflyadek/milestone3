
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>middleware: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">milestone3/be/api/middleware/admin.go (0.0%)</option>
				
				<option value="file1">milestone3/be/api/middleware/auth.go (0.0%)</option>
				
				<option value="file2">milestone3/be/api/middleware/logging.go (0.0%)</option>
				
				<option value="file3">milestone3/be/api/routes/admin_routes.go (0.0%)</option>
				
				<option value="file4">milestone3/be/api/routes/article_routes.go (0.0%)</option>
				
				<option value="file5">milestone3/be/api/routes/auction_routes.go (0.0%)</option>
				
				<option value="file6">milestone3/be/api/routes/bid_routes.go (0.0%)</option>
				
				<option value="file7">milestone3/be/api/routes/donation_routes.go (0.0%)</option>
				
				<option value="file8">milestone3/be/api/routes/final_donation_routes.go (0.0%)</option>
				
				<option value="file9">milestone3/be/api/routes/payment_routes.go (0.0%)</option>
				
				<option value="file10">milestone3/be/api/routes/routes.go (0.0%)</option>
				
				<option value="file11">milestone3/be/api/routes/user_routes.go (0.0%)</option>
				
				<option value="file12">milestone3/be/app/main.go (0.0%)</option>
				
				<option value="file13">milestone3/be/config/connectionDb.go (0.0%)</option>
				
				<option value="file14">milestone3/be/config/redis.go (0.0%)</option>
				
				<option value="file15">milestone3/be/cron/main.go (0.0%)</option>
				
				<option value="file16">milestone3/be/docs/docs.go (0.0%)</option>
				
				<option value="file17">milestone3/be/internal/controller/admin_controller.go (0.0%)</option>
				
				<option value="file18">milestone3/be/internal/controller/article_controller.go (0.0%)</option>
				
				<option value="file19">milestone3/be/internal/controller/auction_item_controller.go (0.0%)</option>
				
				<option value="file20">milestone3/be/internal/controller/auction_session_controller.go (0.0%)</option>
				
				<option value="file21">milestone3/be/internal/controller/bid_controller.go (0.0%)</option>
				
				<option value="file22">milestone3/be/internal/controller/donation_controller.go (0.0%)</option>
				
				<option value="file23">milestone3/be/internal/controller/final_donation_controller.go (0.0%)</option>
				
				<option value="file24">milestone3/be/internal/controller/payment_controller.go (50.0%)</option>
				
				<option value="file25">milestone3/be/internal/controller/user_controller.go (0.0%)</option>
				
				<option value="file26">milestone3/be/internal/dto/article_dto.go (0.0%)</option>
				
				<option value="file27">milestone3/be/internal/dto/auction_dto.go (0.0%)</option>
				
				<option value="file28">milestone3/be/internal/dto/bid_dto.go (0.0%)</option>
				
				<option value="file29">milestone3/be/internal/dto/donation_dto.go (0.0%)</option>
				
				<option value="file30">milestone3/be/internal/mocks/mock_payment_repository.go (0.0%)</option>
				
				<option value="file31">milestone3/be/internal/mocks/mock_payment_service.go (0.0%)</option>
				
				<option value="file32">milestone3/be/internal/mocks/mock_user_repository.go (0.0%)</option>
				
				<option value="file33">milestone3/be/internal/mocks/mock_user_service.go (0.0%)</option>
				
				<option value="file34">milestone3/be/internal/repository/admin_repo.go (0.0%)</option>
				
				<option value="file35">milestone3/be/internal/repository/ai_repo.go (0.0%)</option>
				
				<option value="file36">milestone3/be/internal/repository/article_repo.go (0.0%)</option>
				
				<option value="file37">milestone3/be/internal/repository/auction_item_repo.go (0.0%)</option>
				
				<option value="file38">milestone3/be/internal/repository/auction_session_redis.go (0.0%)</option>
				
				<option value="file39">milestone3/be/internal/repository/auction_session_repo.go (0.0%)</option>
				
				<option value="file40">milestone3/be/internal/repository/bid_redis_repo.go (0.0%)</option>
				
				<option value="file41">milestone3/be/internal/repository/bid_repo.go (0.0%)</option>
				
				<option value="file42">milestone3/be/internal/repository/donation_repo.go (0.0%)</option>
				
				<option value="file43">milestone3/be/internal/repository/final_donation.go (0.0%)</option>
				
				<option value="file44">milestone3/be/internal/repository/gcp_storage_repo.go (0.0%)</option>
				
				<option value="file45">milestone3/be/internal/repository/payment_repo.go (0.0%)</option>
				
				<option value="file46">milestone3/be/internal/repository/user_repo.go (0.0%)</option>
				
				<option value="file47">milestone3/be/internal/service/admin_service.go (0.0%)</option>
				
				<option value="file48">milestone3/be/internal/service/article_service.go (0.0%)</option>
				
				<option value="file49">milestone3/be/internal/service/auction_item_service.go (0.0%)</option>
				
				<option value="file50">milestone3/be/internal/service/auction_session_service.go (0.0%)</option>
				
				<option value="file51">milestone3/be/internal/service/bid_service.go (0.0%)</option>
				
				<option value="file52">milestone3/be/internal/service/donation_service.go (0.0%)</option>
				
				<option value="file53">milestone3/be/internal/service/final_donation_service.go (0.0%)</option>
				
				<option value="file54">milestone3/be/internal/service/payment_service.go (64.0%)</option>
				
				<option value="file55">milestone3/be/internal/service/user_service.go (46.9%)</option>
				
				<option value="file56">milestone3/be/internal/utils/auth.go (0.0%)</option>
				
				<option value="file57">milestone3/be/internal/utils/jwt.go (0.0%)</option>
				
				<option value="file58">milestone3/be/internal/utils/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package middleware

import (
        "milestone3/be/internal/utils"

        "github.com/labstack/echo/v4"
)

// RequireAdmin ensures request has is_admin=true in context (set by auth middleware)
func RequireAdmin(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                if !utils.IsAdmin(c) </span><span class="cov0" title="0">{
                        return utils.ForbiddenResponse(c, "forbidden")
                }</span>
                <span class="cov0" title="0">return next(c)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "net/http"
        "os"

        echojwt "github.com/labstack/echo-jwt/v4"
        "github.com/labstack/echo/v4"
)

// for authentication middleware, such as JWT validation
func JWTMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                jwtSecretKey := os.Getenv("SECRET_KEY")
                jwtMiddleware := echojwt.WithConfig(echojwt.Config{
                        SigningKey: []byte(jwtSecretKey),
                        ErrorHandler: jwtErrorHandler,
                })

                return jwtMiddleware(next)(c)
        }</span>
}

func jwtErrorHandler(c echo.Context, err error) error <span class="cov0" title="0">{
        return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                "message": "you are unauthorized",
        })
}</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "github.com/google/uuid"
        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func makeLogEntry(c echo.Context) *logrus.Entry <span class="cov0" title="0">{
        requestId := uuid.New().String()

        c.Request().Header.Set("X-request-id", requestId)

        return logrus.WithFields(logrus.Fields{
                "request_id": requestId,
                "method": c.Request().Method,
                "uri": c.Request().URL.String(),
                "path": c.Request().URL.Path,
                "query": c.Request().URL.RawQuery,
                "remote_addr": c.Request().RemoteAddr,
        })
}</span>

func LoggingMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                makeLogEntry(c).Info("Incoming HTTP request")
                return next(c)
        }</span>
}

func ErrorHandler(err error, c echo.Context) <span class="cov0" title="0">{
        report, ok := err.(*echo.HTTPError)
        if ok </span><span class="cov0" title="0">{
        report.Message = fmt.Sprintf("http error %d - %v", report.Code, report.Message)
    }</span> else<span class="cov0" title="0"> {
        report = echo.NewHTTPError(http.StatusInternalServerError, err.Error())
    }</span>

    <span class="cov0" title="0">makeLogEntry(c).Error(report.Message)
    c.HTML(report.Code, report.Message.(string))</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package routes

import (
        "milestone3/be/api/middleware"
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterAdminRoutes(adminCtrl *controller.AdminController) <span class="cov0" title="0">{
        adminRoutes := r.echo.Group("admin")
        adminRoutes.Use(middleware.JWTMiddleware)
        adminRoutes.Use(middleware.LoggingMiddleware)

        //admin endpoint
        adminRoutes.GET("/dashboard", adminCtrl.AdminDashboard)
        // adminRoutes.GET("/reports", adminCtrl.AdminReport)
}</pre>
		
		<pre class="file" id="file4" style="display: none">package routes

import (
        "milestone3/be/api/middleware" // import admin middleware
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterArticleRoutes(articleCtrl *controller.ArticleController) <span class="cov0" title="0">{
        articleRoutes := r.echo.Group("/articles")

        // public
        articleRoutes.GET("", articleCtrl.GetAllArticles)
        articleRoutes.GET("/:id", articleCtrl.GetArticleByID)

        // admin-only
        admin := articleRoutes.Group("")
        admin.Use(middleware.JWTMiddleware)
        admin.Use(middleware.RequireAdmin)

        admin.POST("", articleCtrl.CreateArticle)
        admin.PUT("/:id", articleCtrl.UpdateArticle)
        admin.DELETE("/:id", articleCtrl.DeleteArticle)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package routes

import (
        "milestone3/be/api/middleware"
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterAuctionRoutes(auctionCtrl *controller.AuctionController) <span class="cov0" title="0">{
        g := r.echo.Group("/auction/items")
        g.Use(middleware.JWTMiddleware)
        g.Use(middleware.LoggingMiddleware)

        g.GET("", auctionCtrl.GetAllAuctionItems)
        g.GET("/:id", auctionCtrl.GetAuctionItemByID)
        g.POST("", auctionCtrl.CreateAuctionItem)
        g.PUT("/:id", auctionCtrl.UpdateAuctionItem)
        g.DELETE("/:id", auctionCtrl.DeleteAuctionItem)
}</span>

func (r *EchoRouter) RegisterAuctionSessionRoutes(sessionCtrl *controller.AuctionSessionController) <span class="cov0" title="0">{
        g := r.echo.Group("/auction/sessions")
        g.Use(middleware.JWTMiddleware)
        g.Use(middleware.LoggingMiddleware)

        g.GET("", sessionCtrl.GetAllAuctionSessions)
        g.GET("/:id", sessionCtrl.GetAuctionSessionByID)
        g.POST("", sessionCtrl.CreateAuctionSession)
        g.PUT("/:id", sessionCtrl.UpdateAuctionSession)
        g.DELETE("/:id", sessionCtrl.DeleteAuctionSession)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package routes

import (
        "milestone3/be/api/middleware"
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterBidRoutes(bidCtrl *controller.BidController) <span class="cov0" title="0">{
        g := r.echo.Group("/auction/sessions")

        g.Use(middleware.JWTMiddleware)
        g.Use(middleware.LoggingMiddleware)

        g.POST("/:sessionID/items/:itemID/bid", bidCtrl.PlaceBid)
        g.GET("/:sessionID/items/:itemID/highest-bid", bidCtrl.GetHighestBid)
        g.POST("/:sessionID/items/:itemID/sync", bidCtrl.SyncHighestBid)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package routes

import (
        "milestone3/be/api/middleware"
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterDonationRoutes(donationCtrl *controller.DonationController) <span class="cov0" title="0">{
        donationRoutes := r.echo.Group("/donations")

        // public
        donationRoutes.GET("", donationCtrl.GetAllDonations)
        donationRoutes.GET("/:id", donationCtrl.GetDonationByID)

        // authenticated group
        auth := donationRoutes.Group("")
        auth.Use(middleware.JWTMiddleware)

        auth.POST("", donationCtrl.CreateDonation)
        auth.PUT("/:id", donationCtrl.UpdateDonation)
        auth.PATCH("/:id", donationCtrl.PatchDonation)
        auth.DELETE("/:id", donationCtrl.DeleteDonation)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package routes

import (
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterFinalDonationRoutes(finalDonationCtrl *controller.FinalDonationController) <span class="cov0" title="0">{
        finalDonationRoutes := r.echo.Group("/final_donations")

        // public endpoints
        finalDonationRoutes.GET("", finalDonationCtrl.GetAllFinalDonations)
        finalDonationRoutes.GET("/user/:user_id", finalDonationCtrl.GetAllFinalDonationsByUserID)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package routes

import (
        "milestone3/be/api/middleware"
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterPaymentRoutes(paymentCtrl *controller.PaymentController) <span class="cov0" title="0">{
        paymentRoutes := r.echo.Group("/payments")
        paymentRoutes.Use(middleware.JWTMiddleware)
        paymentRoutes.Use(middleware.LoggingMiddleware)

        //payment endpoint
        paymentRoutes.POST("/:auctionId", paymentCtrl.CreatePayment)
        paymentRoutes.GET("/status/:id", paymentCtrl.CheckPaymentStatusMidtrans)
        paymentRoutes.GET("/:id", paymentCtrl.GetPaymentById)
        paymentRoutes.GET("", paymentCtrl.GetAllPayment)
}</pre>
		
		<pre class="file" id="file10" style="display: none">package routes

import (
        "milestone3/be/internal/controller"

        "github.com/labstack/echo/v4"
)

type Router interface {
        RegisterArticleRoutes(articleCtrl *controller.ArticleController)
        RegisterDonationRoutes(donationCtrl *controller.DonationController)
        RegisterUserRoutes(userCtrl *controller.UserController)
        RegisterPaymentRoutes(paymentCtrl *controller.PaymentController)
        // RegisterBiddingRoutes(biddingCtrl *controller.BiddingController)
        RegisterFinalDonationRoutes(finalDonationCtrl *controller.FinalDonationController)
        // RegisterAuthRoutes(authCtrl *controller.AuthController)
        RegisterAuctionRoutes(auctionCtrl *controller.AuctionController)
        RegisterAdminRoutes(adminCtrl *controller.AdminController)
        RegisterAuctionSessionRoutes(sessionCtrl *controller.AuctionSessionController)
        RegisterBidRoutes(bidCtrl *controller.BidController)
}

type EchoRouter struct {
        echo *echo.Echo
}

func NewRouter(e *echo.Echo) Router <span class="cov0" title="0">{
        return &amp;EchoRouter{echo: e}
}</span>

// Example injection method in main:
//  router := routes.NewRouter(e)
//  router.RegisterArticleRoutes(articleCtrl)
//  router.RegisterDonationRoutes(donationCtrl)
</pre>
		
		<pre class="file" id="file11" style="display: none">package routes

import (
        "milestone3/be/api/middleware"
        "milestone3/be/internal/controller"
)

func (r *EchoRouter) RegisterUserRoutes(userCtrl *controller.UserController) <span class="cov0" title="0">{
        userRoutes := r.echo.Group("auth")
        userRoutes.Use(middleware.LoggingMiddleware)

        // auth endpoint
        userRoutes.POST("/register", userCtrl.CreateUser)
        userRoutes.GET("/login", userCtrl.LoginUser)
}</pre>
		
		<pre class="file" id="file12" style="display: none">// Your Donate Rise API
// @title Your Donate Rise API
// @version 1.0
// @description A comprehensive donation and auction management system that transforms donated goods into meaningful impact through transparent auctions and direct donations to institutions in need.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host yourdonaterise-278016640112.asia-southeast2.run.app
// @BasePath /
// @schemes https http

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

package main

import (
        "context"
        "log"
        "log/slog"
        "os"

        "cloud.google.com/go/storage"
        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"
        "github.com/swaggo/echo-swagger"

        "milestone3/be/api/routes"
        "milestone3/be/config"
        "milestone3/be/internal/controller"
        "milestone3/be/internal/repository"
        "milestone3/be/internal/service"
        _ "milestone3/be/docs" // swagger docs
)

var loggerOption = slog.HandlerOptions{AddSource: true}
var logger = slog.New(slog.NewJSONHandler(os.Stdout, &amp;loggerOption))

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        db := config.ConnectionDb()
        validate := validator.New()

        // GCP PUBLIC BUCKET
        var gcpPublicRepo repository.GCPStorageRepo
        publicBucket := os.Getenv("PUBLIC_BUCKET")

        if publicBucket != "" </span><span class="cov0" title="0">{
                client, err := storage.NewClient(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to create public gcs client: %v", err)
                }</span>
                <span class="cov0" title="0">gcpPublicRepo = repository.NewGCPStorageRepo(client, publicBucket, true)</span>
        } else<span class="cov0" title="0"> {
                log.Println("PUBLIC_BUCKET NOT SET")
        }</span>

        // GCP PRIVATE BUCKET
        <span class="cov0" title="0">var gcpPrivateRepo repository.GCPStorageRepo
        privateBucket := os.Getenv("PRIVATE_BUCKET")

        if privateBucket != "" </span><span class="cov0" title="0">{
                client, err := storage.NewClient(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to create private gcs client: %v", err)
                }</span>
                <span class="cov0" title="0">gcpPrivateRepo = repository.NewGCPStorageRepo(client, privateBucket, false)</span>
        } else<span class="cov0" title="0"> {
                log.Println("PRIVATE_BUCKET NOT SET")
        }</span>

        // repositories
        <span class="cov0" title="0">userRepo := repository.NewUserRepo(db, ctx)
        articleRepo := repository.NewArticleRepo(db)
        donationRepo := repository.NewDonationRepo(db)
        finalDonationRepo := repository.NewFinalDonationRepository(db)
        paymentRepo := repository.NewPaymentRepository(db, ctx)
        adminRepo := repository.NewAdminRepository(db, ctx)
        auctionItemRepo := repository.NewAuctionItemRepository(db)
        auctionSessionRepo := repository.NewAuctionSessionRepository(db)
        bidRepo := repository.NewBidRepository(db)
        redisClient := config.ConnectRedis(ctx)
        redisRepo := repository.NewBidRedisRepository(redisClient, ctx)
        auctionRedisRepo := repository.NewSessionRedisRepository(redisClient, ctx)
        aiRepo := repository.NewAIRepository(logger, os.Getenv("GEMINI_API_KEY"))

        // services
        userSvc := service.NewUserService(userRepo)
        articleSvc := service.NewArticleService(articleRepo)
        donationSvc := service.NewDonationService(donationRepo, gcpPrivateRepo)
        finalDonationSvc := service.NewFinalDonationService(finalDonationRepo)
        paymentSvc := service.NewPaymentService(paymentRepo)
        adminSvc := service.NewAdminService(adminRepo)
        bidSvc := service.NewBidService(redisRepo, bidRepo, auctionItemRepo, logger)
        auctionSvc := service.NewAuctionItemService(auctionItemRepo, aiRepo, logger)

        // controllers
        userCtrl := controller.NewUserController(validate, userSvc)
        adminCtrl := controller.NewAdminController(adminSvc)
        auctionSessionSvc := service.NewAuctionSessionService(auctionSessionRepo, auctionRedisRepo, logger)
        articleCtrl := controller.NewArticleController(articleSvc, gcpPublicRepo)

        var donationCtrl *controller.DonationController
        if gcpPrivateRepo != nil </span><span class="cov0" title="0">{
                donationCtrl = controller.NewDonationController(donationSvc, gcpPrivateRepo)
        }</span> else<span class="cov0" title="0"> {
                donationCtrl = controller.NewDonationController(donationSvc, nil)
        }</span>
        <span class="cov0" title="0">finalDonationCtrl := controller.NewFinalDonationController(finalDonationSvc)
        paymentCtrl := controller.NewPaymentController(validate, paymentSvc)
        auctionCtrl := controller.NewAuctionController(auctionSvc, validate)
        auctionSessionCtrl := controller.NewAuctionSessionController(auctionSessionSvc, validate)
        bidCtrl := controller.NewBidController(bidSvc, auctionSessionSvc, validate)

        // echo + router
        e := echo.New()
        router := routes.NewRouter(e)

        // Swagger route
        e.GET("/swagger/*", echoSwagger.WrapHandler)

        router.RegisterUserRoutes(userCtrl)
        router.RegisterArticleRoutes(articleCtrl)
        router.RegisterDonationRoutes(donationCtrl)
        router.RegisterFinalDonationRoutes(finalDonationCtrl)
        router.RegisterPaymentRoutes(paymentCtrl)
        router.RegisterAdminRoutes(adminCtrl)
        router.RegisterAuctionRoutes(auctionCtrl)
        router.RegisterAuctionSessionRoutes(auctionSessionCtrl)
        router.RegisterBidRoutes(bidCtrl)

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>
        <span class="cov0" title="0">if err := e.Start(":" + port); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "fmt"
        "log"
        "os"

        "github.com/joho/godotenv"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func ConnectionDb() *gorm.DB <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("error load env %s", err)
        }</span>

        <span class="cov0" title="0">dsn := os.Getenv("POSTGRE_URL")
        db, err := gorm.Open(postgres.Open(dsn))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error connect to database %s", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("success connect to db")
        return db</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "context"
        "log"
        "os"

        "github.com/redis/go-redis/v9"
)

func ConnectRedis(ctx context.Context) *redis.Client <span class="cov0" title="0">{
        url := os.Getenv("REDIS_URL")
        if url == "" </span><span class="cov0" title="0">{
                log.Fatal("REDIS_URL not set")
        }</span>

        <span class="cov0" title="0">opt, err := redis.ParseURL(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed parsing redis url: %v", err)
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(opt)

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to redis: %v", err)
        }</span>

        <span class="cov0" title="0">return client</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "context"
        "log/slog"
        "milestone3/be/config"
        "milestone3/be/internal/repository"
        "milestone3/be/internal/service"
        "os"

        "github.com/robfig/cron/v3"
)

var (
        loggerOption = slog.HandlerOptions{AddSource: true}
        logger       = slog.New(slog.NewJSONHandler(os.Stdout, &amp;loggerOption))
)

func main() <span class="cov0" title="0">{
        db := config.ConnectionDb()
        ctx := context.Background()
        redisClient := config.ConnectRedis(ctx)

        redisRepo := repository.NewBidRedisRepository(redisClient, ctx)
        bidRepo := repository.NewBidRepository(db)
        auctionItemRepo := repository.NewAuctionItemRepository(db)

        bidSvc := service.NewBidService(redisRepo, bidRepo, auctionItemRepo, logger)

        c := cron.New()
        c.AddFunc("0 0 0 * * *", func() </span><span class="cov0" title="0">{
                bidSvc.SaveExpiredSessions(0)
        }</span>)
        <span class="cov0" title="0">c.Start()

        select </span>{}
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/admin/dashboard": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get comprehensive dashboard analytics including donation stats, auction metrics, and system overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Admin"
                ],
                "summary": "Get admin dashboard analytics",
                "responses": {
                    "200": {
                        "description": "Dashboard data retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/articles": {
            "get": {
                "description": "Retrieve all published weekly transparency articles",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Articles"
                ],
                "summary": "Get all transparency articles",
                "responses": {
                    "200": {
                        "description": "Articles retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new weekly transparency article with optional image upload",
                "consumes": [
                    "multipart/form-data",
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Articles"
                ],
                "summary": "Create new transparency article",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Article title",
                        "name": "title",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Article content",
                        "name": "content",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Week number",
                        "name": "week",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Article image (optional)",
                        "name": "image",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Article created successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payload or image",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/articles/{id}": {
            "get": {
                "description": "Retrieve a specific transparency article by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Articles"
                ],
                "summary": "Get article by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Article ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Article retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid article ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Article not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing transparency article by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Articles"
                ],
                "summary": "Update existing article",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Article ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated article data",
                        "name": "article",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Article updated successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID or payload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Article not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete a transparency article by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Articles"
                ],
                "summary": "Delete article",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Article ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Article deleted successfully"
                    },
                    "400": {
                        "description": "Bad request - Invalid article ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Article not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/items": {
            "get": {
                "description": "Retrieve all available auction items",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Items"
                ],
                "summary": "Get all auction items",
                "responses": {
                    "200": {
                        "description": "Auction items retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new auction item from verified donation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Items"
                ],
                "summary": "Create new auction item",
                "parameters": [
                    {
                        "description": "Auction item data",
                        "name": "auctionItem",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Auction item created successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/items/{id}": {
            "get": {
                "description": "Retrieve a specific auction item by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Items"
                ],
                "summary": "Get auction item by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Auction item retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid auction item ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction item not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing auction item by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Items"
                ],
                "summary": "Update auction item",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated auction item data",
                        "name": "auctionItem",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Auction item updated successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID or payload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction item not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete an auction item by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Items"
                ],
                "summary": "Delete auction item",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Auction item deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID or cannot delete item",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction item not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/sessions": {
            "get": {
                "description": "Retrieve all auction sessions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Sessions"
                ],
                "summary": "Get all auction sessions",
                "responses": {
                    "200": {
                        "description": "Auction sessions retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "No auction sessions found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new auction session with start and end times",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Sessions"
                ],
                "summary": "Create new auction session",
                "parameters": [
                    {
                        "description": "Auction session data",
                        "name": "auctionSession",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Auction session created successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/sessions/{id}": {
            "get": {
                "description": "Retrieve a specific auction session by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Sessions"
                ],
                "summary": "Get auction session by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Session ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Auction session retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid auction session ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction session not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing auction session by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Sessions"
                ],
                "summary": "Update auction session",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Session ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated auction session data",
                        "name": "auctionSession",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Auction session updated successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID, payload, or session is active",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction session not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete an auction session by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Auction Sessions"
                ],
                "summary": "Delete auction session",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Session ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Auction session deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID or session is active",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction session not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/sessions/{sessionID}/items/{itemID}/bid": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Place a bid on a specific auction item within an active session",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Bidding"
                ],
                "summary": "Place bid on auction item",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Session ID",
                        "name": "sessionID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "itemID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Bid amount",
                        "name": "bid",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Bid placed successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid parameters or bid too low",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction session or item not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict - Invalid auction state",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/sessions/{sessionID}/items/{itemID}/highest-bid": {
            "get": {
                "description": "Retrieve the current highest bid for a specific auction item",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Bidding"
                ],
                "summary": "Get highest bid for auction item",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Session ID",
                        "name": "sessionID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "itemID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Highest bid retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid session or item ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Auction not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auction/sessions/{sessionID}/items/{itemID}/sync": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Synchronize the highest bid from Redis cache to the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Bidding"
                ],
                "summary": "Sync highest bid to database",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Session ID",
                        "name": "sessionID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "itemID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Highest bid synced to database",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid session or item ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Admin access required",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Authenticate user and return access token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Authentication"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User login credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful, returns access token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid credentials format",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid email or password",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a new user account in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Authentication"
                ],
                "summary": "Register new user",
                "parameters": [
                    {
                        "description": "User registration data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User created successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payload or validation error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/donations": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get all donations (admin sees all, users see only their own)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Donations"
                ],
                "summary": "Get all donations",
                "responses": {
                    "200": {
                        "description": "Donations retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Submit a new donation with photos and details",
                "consumes": [
                    "multipart/form-data",
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Donations"
                ],
                "summary": "Create new donation",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Donation title",
                        "name": "title",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Donation description",
                        "name": "description",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Donation category",
                        "name": "category",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Item condition",
                        "name": "condition",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Donation photos (multiple files allowed)",
                        "name": "photos",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Donation created successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payload or file upload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/donations/final": {
            "get": {
                "description": "Retrieve all items that were directly donated to institutions",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Final Donations"
                ],
                "summary": "Get all final donations",
                "responses": {
                    "200": {
                        "description": "Final donations retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Failed to fetch final donations",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/donations/final/user/{user_id}": {
            "get": {
                "description": "Retrieve all final donations made by a specific user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Final Donations"
                ],
                "summary": "Get final donations by user ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Final donations retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid user ID or failed to fetch",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/donations/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve a specific donation by ID (owner or admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Donations"
                ],
                "summary": "Get donation by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Donation ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Donation retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid donation ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Access denied",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Donation not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing donation (owner or admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Donations"
                ],
                "summary": "Update donation",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Donation ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated donation data",
                        "name": "donation",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Donation updated successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID or payload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Access denied",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Donation not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete a donation by ID (owner or admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Donations"
                ],
                "summary": "Delete donation",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Donation ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Donation deleted successfully"
                    },
                    "400": {
                        "description": "Bad request - Invalid donation ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Access denied",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Donation not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Partially update a donation by ID (owner or admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Donations"
                ],
                "summary": "Partially update donation",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Donation ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Partial donation data",
                        "name": "donation",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Donation patched successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid ID or payload",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Access denied",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "404": {
                        "description": "Donation not found",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/payments": {
            "get": {
                "description": "Retrieve all payment transactions in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Payments"
                ],
                "summary": "Get all payments",
                "responses": {
                    "200": {
                        "description": "Payments retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/payments/auction/{auctionId}": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a payment transaction for a won auction item",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Payments"
                ],
                "summary": "Create payment for auction item",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Auction Item ID",
                        "name": "auctionId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Payment details",
                        "name": "payment",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Payment created successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payload or auction ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "401": {
                        "description": "Unauthorized - Invalid or missing token",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/payments/status/{id}": {
            "get": {
                "description": "Check the payment status of an order through Midtrans payment gateway",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Payments"
                ],
                "summary": "Check payment status via Midtrans",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Payment status retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        },
        "/payments/{id}": {
            "get": {
                "description": "Retrieve payment information by payment ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Your Donate Rise API - Payments"
                ],
                "summary": "Get payment by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Payment ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Payment retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "400": {
                        "description": "Bad request - Invalid payment ID",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.Response"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "utils.Response": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string",
                    "example": "Operation completed successfully"
                },
                "status": {
                    "type": "string",
                    "example": "success"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "yourdonaterise-278016640112.asia-southeast2.run.app",
        BasePath:         "/",
        Schemes:          []string{"https", "http"},
        Title:            "Your Donate Rise API",
        Description:      "A comprehensive donation and auction management system that transforms donated goods into meaningful impact through transparent auctions and direct donations to institutions in need.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package controller

import (
        "milestone3/be/internal/dto"
        "milestone3/be/internal/utils"

        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type AdminService interface {
        AdminDashboard() (resp dto.AdminDashboardResponse, err error)
        // AdminReport() (err error)
}

type AdminController struct {
        adminService AdminService
}

func NewAdminController(as AdminService) *AdminController <span class="cov0" title="0">{
        return &amp;AdminController{adminService: as}
}</span>

// AdminDashboard godoc
// @Summary Get admin dashboard analytics
// @Description Get comprehensive dashboard analytics including donation stats, auction metrics, and system overview
// @Tags Your Donate Rise API - Admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} utils.Response "Dashboard data retrieved successfully"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /admin/dashboard [get]
func (ac *AdminController) AdminDashboard(c echo.Context) error <span class="cov0" title="0">{
        user := c.Get("user").(*jwt.Token)
        claim := user.Claims.(jwt.MapClaims)
        role := claim["role"].(string)

        if role != "admin" </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "forbidden request")
        }</span>
        
        <span class="cov0" title="0">resp, err := ac.adminService.AdminDashboard()
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov0" title="0">return utils.SuccessResponse(c, "ok", resp)</span>
}

// WIP
// func (ac *AdminController) AdminReport(c echo.Context) error {

// }</pre>
		
		<pre class="file" id="file18" style="display: none">package controller

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "milestone3/be/internal/dto"
        "milestone3/be/internal/repository"
        "milestone3/be/internal/service"
        "milestone3/be/internal/utils"

        "github.com/labstack/echo/v4"
)

type ArticleController struct {
        svc           service.ArticleService
        storagePublic repository.GCPStorageRepo
}

func NewArticleController(s service.ArticleService, storage repository.GCPStorageRepo) *ArticleController <span class="cov0" title="0">{
        return &amp;ArticleController{svc: s, storagePublic: storage}
}</span>

// GetAllArticles godoc
// @Summary Get all transparency articles
// @Description Retrieve all published weekly transparency articles
// @Tags Your Donate Rise API - Articles
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response "Articles retrieved successfully"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /articles [get]
func (h *ArticleController) GetAllArticles(c echo.Context) error <span class="cov0" title="0">{
        articles, err := h.svc.GetAllArticles()
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed fetching articles")
        }</span>
        <span class="cov0" title="0">return utils.SuccessResponse(c, "articles fetched", articles)</span>
}

// GetArticleByID godoc
// @Summary Get article by ID
// @Description Retrieve a specific transparency article by its ID
// @Tags Your Donate Rise API - Articles
// @Accept json
// @Produce json
// @Param id path int true "Article ID"
// @Success 200 {object} utils.Response "Article retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid article ID"
// @Failure 404 {object} utils.Response "Article not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /articles/{id} [get]
func (h *ArticleController) GetArticleByID(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>
        <span class="cov0" title="0">article, err := h.svc.GetArticleByID(uint(id64))
        if err != nil </span><span class="cov0" title="0">{
                if err == service.ErrArticleNotFound </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "article not found")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed fetching article")</span>
        }
        <span class="cov0" title="0">return utils.SuccessResponse(c, "article fetched", article)</span>
}

// CreateArticle godoc
// @Summary Create new transparency article
// @Description Create a new weekly transparency article with optional image upload
// @Tags Your Donate Rise API - Articles
// @Accept multipart/form-data
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param title formData string true "Article title"
// @Param content formData string true "Article content"
// @Param week formData int true "Week number"
// @Param image formData file false "Article image (optional)"
// @Success 201 {object} utils.Response "Article created successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payload or image"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /articles [post]
func (h *ArticleController) CreateArticle(c echo.Context) error <span class="cov0" title="0">{
        if !utils.IsAdmin(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "admin only")
        }</span>

        <span class="cov0" title="0">contentType := c.Request().Header.Get("Content-Type")
        var payload dto.ArticleDTO

        // if multipart/form-data (with image)
        if strings.HasPrefix(contentType, "multipart/form-data") </span><span class="cov0" title="0">{
                if err := c.Request().ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                        return utils.BadRequestResponse(c, "invalid multipart form")
                }</span>

                <span class="cov0" title="0">form := c.Request().MultipartForm

                payload.Title = form.Value["title"][0]
                payload.Content = form.Value["content"][0]
                week, _ := strconv.Atoi(form.Value["week"][0])
                payload.Week = week

                // handle image (opsional)
                if fhs, ok := form.File["image"]; ok &amp;&amp; len(fhs) &gt; 0 </span><span class="cov0" title="0">{
                        fh := fhs[0]

                        file, err := fh.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return utils.BadRequestResponse(c, "failed open image")
                        }</span>
                        <span class="cov0" title="0">defer file.Close()

                        objName := fmt.Sprintf("articles/%d_%s", time.Now().UnixNano(), fh.Filename)

                        //  upload to public storage
                        url, err := h.storagePublic.UploadFile(c.Request().Context(), file, objName)
                        if err != nil </span><span class="cov0" title="0">{
                                return utils.InternalServerErrorResponse(c, "failed uploading image")
                        }</span>

                        <span class="cov0" title="0">payload.Image = url</span>
                }

        } else<span class="cov0" title="0"> {
                // support JSON without image
                if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                        return utils.BadRequestResponse(c, "invalid payload")
                }</span>
        }

        // send to service
        <span class="cov0" title="0">if err := h.svc.CreateArticle(payload); err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed creating article")
        }</span>

        <span class="cov0" title="0">return utils.CreatedResponse(c, "article created", nil)</span>
}

// UpdateArticle godoc
// @Summary Update existing article
// @Description Update an existing transparency article by ID
// @Tags Your Donate Rise API - Articles
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Article ID"
// @Param article body object true "Updated article data"
// @Success 200 {object} utils.Response "Article updated successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID or payload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 404 {object} utils.Response "Article not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /articles/{id} [put]
func (h *ArticleController) UpdateArticle(c echo.Context) error <span class="cov0" title="0">{
        if !utils.IsAdmin(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "admin only")
        }</span>
        <span class="cov0" title="0">var payload dto.ArticleDTO
        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>
        <span class="cov0" title="0">idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>
        <span class="cov0" title="0">payload.ID = uint(id64)
        if err := h.svc.UpdateArticle(payload); err != nil </span><span class="cov0" title="0">{
                if err == service.ErrArticleNotFound </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "article not found")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed updating article")</span>
        }
        <span class="cov0" title="0">return utils.SuccessResponse(c, "article updated", nil)</span>
}

// DeleteArticle godoc
// @Summary Delete article
// @Description Delete a transparency article by ID
// @Tags Your Donate Rise API - Articles
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Article ID"
// @Success 204 "Article deleted successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid article ID"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 404 {object} utils.Response "Article not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /articles/{id} [delete]
func (h *ArticleController) DeleteArticle(c echo.Context) error <span class="cov0" title="0">{
        if !utils.IsAdmin(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "admin only")
        }</span>
        <span class="cov0" title="0">idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>
        <span class="cov0" title="0">if err := h.svc.DeleteArticle(uint(id64)); err != nil </span><span class="cov0" title="0">{
                if err == service.ErrArticleNotFound </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "article not found")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed deleting article")</span>
        }
        <span class="cov0" title="0">return utils.NoContentResponse(c)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package controller

import (
        "milestone3/be/internal/dto"
        "milestone3/be/internal/service"
        "milestone3/be/internal/utils"
        "strconv"

        "github.com/go-playground/validator/v10"
        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type AuctionController struct {
        svc      service.AuctionItemService
        validate *validator.Validate
}

func NewAuctionController(s service.AuctionItemService, validate *validator.Validate) *AuctionController <span class="cov0" title="0">{
        return &amp;AuctionController{svc: s, validate: validate}
}</span>

func getUserIDFromTokenItem(c echo.Context) (int64, error) <span class="cov0" title="0">{
        token := c.Get("user")
        if token == nil </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(401, "unauthenticated")
        }</span>

        <span class="cov0" title="0">claims, ok := token.(*jwt.Token).Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(401, "invalid token")
        }</span>

        <span class="cov0" title="0">userIDFloat, ok := claims["id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(401, "invalid token")
        }</span>

        <span class="cov0" title="0">return int64(userIDFloat), nil</span>
}

// Helper function to check if user is admin from JWT token
func isAdminFromTokenItem(c echo.Context) bool <span class="cov0" title="0">{
        token := c.Get("user")
        if token == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">claims, ok := token.(*jwt.Token).Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">role, ok := claims["role"].(string)
        return ok &amp;&amp; role == "admin"</span>
}

// CreateAuctionItem godoc
// @Summary Create new auction item
// @Description Create a new auction item from verified donation
// @Tags Your Donate Rise API - Auction Items
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param auctionItem body object true "Auction item data"
// @Success 201 {object} utils.Response "Auction item created successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/items [post]
func (h *AuctionController) CreateAuctionItem(c echo.Context) error <span class="cov0" title="0">{
        // Check if user is admin
        if !isAdminFromTokenItem(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can create auction items")
        }</span>

        // Get user ID from JWT token
        <span class="cov0" title="0">userID, err := getUserIDFromTokenItem(c)
        if err != nil </span><span class="cov0" title="0">{
                return utils.UnauthorizedResponse(c, "unauthenticated")
        }</span>

        <span class="cov0" title="0">var payload dto.AuctionItemDTO
        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>

        <span class="cov0" title="0">if err := h.validate.Struct(payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">payload.UserID = userID
        createdItem, err := h.svc.Create(&amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed creating auction item")
        }</span>

        <span class="cov0" title="0">return utils.CreatedResponse(c, "auction item created successfully", createdItem)</span>
}

// GetAllAuctionItems godoc
// @Summary Get all auction items
// @Description Retrieve all available auction items
// @Tags Your Donate Rise API - Auction Items
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response "Auction items retrieved successfully"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/items [get]
func (h *AuctionController) GetAllAuctionItems(c echo.Context) error <span class="cov0" title="0">{
        items, err := h.svc.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed retrieving auction items")
        }</span>
        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction items retrieved successfully", items)</span>
}

// GetAuctionItemByID godoc
// @Summary Get auction item by ID
// @Description Retrieve a specific auction item by its ID
// @Tags Your Donate Rise API - Auction Items
// @Accept json
// @Produce json
// @Param id path int true "Auction Item ID"
// @Success 200 {object} utils.Response "Auction item retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid auction item ID"
// @Failure 404 {object} utils.Response "Auction item not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/items/{id} [get]
func (h *AuctionController) GetAuctionItemByID(c echo.Context) error <span class="cov0" title="0">{
        idStr := c.Param("id")

        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid auction item ID")
        }</span>

        <span class="cov0" title="0">item, err := h.svc.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFoundID:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, "auction item not found")</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed retrieving auction item")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction item retrieved successfully", item)</span>
}

// UpdateAuctionItem godoc
// @Summary Update auction item
// @Description Update an existing auction item by ID
// @Tags Your Donate Rise API - Auction Items
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Auction Item ID"
// @Param auctionItem body object true "Updated auction item data"
// @Success 200 {object} utils.Response "Auction item updated successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID or payload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 404 {object} utils.Response "Auction item not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/items/{id} [put]
func (h *AuctionController) UpdateAuctionItem(c echo.Context) error <span class="cov0" title="0">{
        // Check if user is admin
        if !isAdminFromTokenItem(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can update auction items")
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid auction item ID")
        }</span>

        <span class="cov0" title="0">var payload dto.AuctionItemDTO
        if err = c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>

        <span class="cov0" title="0">if err = h.validate.Struct(payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">updatedItem, err := h.svc.Update(id, &amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFoundID:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, "auction item not found")</span>
                case service.ErrInvalidAuction:<span class="cov0" title="0">
                        return utils.BadRequestResponse(c, "invalid auction item data")</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed updating auction item")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction item updated successfully", updatedItem)</span>
}

// DeleteAuctionItem godoc
// @Summary Delete auction item
// @Description Delete an auction item by ID
// @Tags Your Donate Rise API - Auction Items
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Auction Item ID"
// @Success 200 {object} utils.Response "Auction item deleted successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID or cannot delete item"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 404 {object} utils.Response "Auction item not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/items/{id} [delete]
func (h *AuctionController) DeleteAuctionItem(c echo.Context) error <span class="cov0" title="0">{
        // Check if user is admin
        if !isAdminFromTokenItem(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can delete auction items")
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid auction item ID")
        }</span>

        <span class="cov0" title="0">err = h.svc.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFoundID:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, "auction item not found")</span>
                case service.ErrInvalidAuction:<span class="cov0" title="0">
                        return utils.BadRequestResponse(c, "cannot delete auction item")</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed deleting auction item")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction item deleted successfully", nil)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package controller

import (
        "milestone3/be/internal/dto"
        "milestone3/be/internal/service"
        "milestone3/be/internal/utils"
        "strconv"

        "github.com/go-playground/validator/v10"
        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type AuctionSessionController struct {
        svc      service.AuctionSessionService
        validate *validator.Validate
}

func NewAuctionSessionController(s service.AuctionSessionService, validate *validator.Validate) *AuctionSessionController <span class="cov0" title="0">{
        return &amp;AuctionSessionController{svc: s, validate: validate}
}</span>

func isAdminFromTokenSession(c echo.Context) bool <span class="cov0" title="0">{
        token := c.Get("user")
        if token == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">claims, ok := token.(*jwt.Token).Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">role, ok := claims["role"].(string)
        return ok &amp;&amp; role == "admin"</span>
}

// CreateAuctionSession godoc
// @Summary Create new auction session
// @Description Create a new auction session with start and end times
// @Tags Your Donate Rise API - Auction Sessions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param auctionSession body object true "Auction session data"
// @Success 201 {object} utils.Response "Auction session created successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions [post]
func (h *AuctionSessionController) CreateAuctionSession(c echo.Context) error <span class="cov0" title="0">{
        if !isAdminFromTokenSession(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can create auction sessions")
        }</span>

        <span class="cov0" title="0">var payload dto.AuctionSessionDTO
        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>

        <span class="cov0" title="0">if err := h.validate.Struct(payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">createdSession, err := h.svc.Create(&amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed to create auction session")
        }</span>

        <span class="cov0" title="0">return utils.CreatedResponse(c, "auction session created successfully", createdSession)</span>
}

// GetAuctionSessionByID godoc
// @Summary Get auction session by ID
// @Description Retrieve a specific auction session by its ID
// @Tags Your Donate Rise API - Auction Sessions
// @Accept json
// @Produce json
// @Param id path int true "Auction Session ID"
// @Success 200 {object} utils.Response "Auction session retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid auction session ID"
// @Failure 404 {object} utils.Response "Auction session not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions/{id} [get]
func (h *AuctionSessionController) GetAuctionSessionByID(c echo.Context) error <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid auction session ID")
        }</span>

        <span class="cov0" title="0">session, err := h.svc.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFound:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, err.Error())</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed to retrieve auction session")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction session retrieved successfully", session)</span>
}

// GetAllAuctionSessions godoc
// @Summary Get all auction sessions
// @Description Retrieve all auction sessions
// @Tags Your Donate Rise API - Auction Sessions
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response "Auction sessions retrieved successfully"
// @Failure 404 {object} utils.Response "No auction sessions found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions [get]
func (h *AuctionSessionController) GetAllAuctionSessions(c echo.Context) error <span class="cov0" title="0">{
        sessions, err := h.svc.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFound:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, err.Error())</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed to retrieve auction sessions")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction sessions retrieved successfully", sessions)</span>
}

// UpdateAuctionSession godoc
// @Summary Update auction session
// @Description Update an existing auction session by ID
// @Tags Your Donate Rise API - Auction Sessions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Auction Session ID"
// @Param auctionSession body object true "Updated auction session data"
// @Success 200 {object} utils.Response "Auction session updated successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID, payload, or session is active"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 404 {object} utils.Response "Auction session not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions/{id} [put]
func (h *AuctionSessionController) UpdateAuctionSession(c echo.Context) error <span class="cov0" title="0">{
        if !isAdminFromTokenSession(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can update auction sessions")
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid auction session ID")
        }</span>

        <span class="cov0" title="0">var payload dto.AuctionSessionDTO
        if err = c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>

        <span class="cov0" title="0">if err = h.validate.Struct(payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">updatedSession, err := h.svc.Update(id, &amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFoundID:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, err.Error())</span>
                case service.ErrActiveSession:<span class="cov0" title="0">
                        return utils.BadRequestResponse(c, err.Error())</span>
                case service.ErrInvalidDate:<span class="cov0" title="0">
                        return utils.BadRequestResponse(c, err.Error())</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed to update auction session")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction session updated successfully", updatedSession)</span>
}

// DeleteAuctionSession godoc
// @Summary Delete auction session
// @Description Delete an auction session by ID
// @Tags Your Donate Rise API - Auction Sessions
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Auction Session ID"
// @Success 200 {object} utils.Response "Auction session deleted successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID or session is active"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 404 {object} utils.Response "Auction session not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions/{id} [delete]
func (h *AuctionSessionController) DeleteAuctionSession(c echo.Context) error <span class="cov0" title="0">{
        if !isAdminFromTokenSession(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can delete auction sessions")
        }</span>

        <span class="cov0" title="0">idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid auction session ID")
        }</span>

        <span class="cov0" title="0">err = h.svc.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFoundID:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, err.Error())</span>
                case service.ErrActiveSession, service.ErrInvalidDate:<span class="cov0" title="0">
                        return utils.BadRequestResponse(c, err.Error())</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed to delete auction session")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "auction session deleted successfully", nil)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package controller

import (
        "milestone3/be/internal/dto"
        "milestone3/be/internal/service"
        "milestone3/be/internal/utils"
        "strconv"

        "github.com/go-playground/validator/v10"
        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type BidController struct {
        svc        service.BidService
        sessionSvc service.AuctionSessionService
        validate   *validator.Validate
}

func NewBidController(s service.BidService, sessionSvc service.AuctionSessionService, validate *validator.Validate) *BidController <span class="cov0" title="0">{
        return &amp;BidController{svc: s, sessionSvc: sessionSvc, validate: validate}
}</span>

func getUserIDFromToken(c echo.Context) (int64, error) <span class="cov0" title="0">{
        token := c.Get("user")
        if token == nil </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(401, "unauthenticated")
        }</span>

        <span class="cov0" title="0">claims, ok := token.(*jwt.Token).Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(401, "invalid token")
        }</span>

        <span class="cov0" title="0">userIDFloat, ok := claims["id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(401, "invalid token")
        }</span>

        <span class="cov0" title="0">return int64(userIDFloat), nil</span>
}

func isAdminFromToken(c echo.Context) bool <span class="cov0" title="0">{
        token := c.Get("user")
        if token == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">claims, ok := token.(*jwt.Token).Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">role, ok := claims["role"].(string)
        return ok &amp;&amp; role == "admin"</span>
}

// PlaceBid godoc
// @Summary Place bid on auction item
// @Description Place a bid on a specific auction item within an active session
// @Tags Your Donate Rise API - Bidding
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param sessionID path int true "Auction Session ID"
// @Param itemID path int true "Auction Item ID"
// @Param bid body object true "Bid amount"
// @Success 200 {object} utils.Response "Bid placed successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid parameters or bid too low"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 404 {object} utils.Response "Auction session or item not found"
// @Failure 409 {object} utils.Response "Conflict - Invalid auction state"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions/{sessionID}/items/{itemID}/bid [post]
func (h *BidController) PlaceBid(c echo.Context) error <span class="cov0" title="0">{
        sessionIDStr := c.Param("sessionID")
        itemIDStr := c.Param("itemID")

        sessionID, err := strconv.ParseInt(sessionIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid sessionID")
        }</span>

        <span class="cov0" title="0">itemID, err := strconv.ParseInt(itemIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid itemID")
        }</span>

        <span class="cov0" title="0">var payload dto.BidDTO
        if err = c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>

        <span class="cov0" title="0">if err = h.validate.Struct(payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">userID, err := getUserIDFromToken(c)
        if err != nil </span><span class="cov0" title="0">{
                return utils.UnauthorizedResponse(c, "unauthenticated")
        }</span>

        <span class="cov0" title="0">session, err := h.sessionSvc.GetByID(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return utils.NotFoundResponse(c, "auction session not found")
        }</span>
        <span class="cov0" title="0">err = h.svc.PlaceBid(
                sessionID,
                itemID,
                userID,
                payload.Amount,
                session.EndTime,
        )

        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrBidTooLow, service.ErrInvalidBidding:<span class="cov0" title="0">
                        return utils.BadRequestResponse(c, err.Error())</span>
                case service.ErrAuctionNotFound:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, err.Error())</span>
                case service.ErrInvalidAuction:<span class="cov0" title="0">
                        return utils.ConflictResponse(c, err.Error())</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed placing bid")</span>
                }
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "bid placed successfully", nil)</span>
}

// GetHighestBid godoc
// @Summary Get highest bid for auction item
// @Description Retrieve the current highest bid for a specific auction item
// @Tags Your Donate Rise API - Bidding
// @Accept json
// @Produce json
// @Param sessionID path int true "Auction Session ID"
// @Param itemID path int true "Auction Item ID"
// @Success 200 {object} utils.Response "Highest bid retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid session or item ID"
// @Failure 404 {object} utils.Response "Auction not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions/{sessionID}/items/{itemID}/highest-bid [get]
func (h *BidController) GetHighestBid(c echo.Context) error <span class="cov0" title="0">{
        sessionIDStr := c.Param("sessionID")
        itemIDStr := c.Param("itemID")

        sessionID, err := strconv.ParseInt(sessionIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid sessionID")
        }</span>

        <span class="cov0" title="0">itemID, err := strconv.ParseInt(itemIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid itemID")
        }</span>

        <span class="cov0" title="0">highest, bidder, err := h.svc.GetHighestBid(sessionID, itemID)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case service.ErrAuctionNotFound:<span class="cov0" title="0">
                        return utils.NotFoundResponse(c, err.Error())</span>
                default:<span class="cov0" title="0">
                        return utils.InternalServerErrorResponse(c, "failed retrieving highest bid")</span>
                }
        }

        <span class="cov0" title="0">resp := map[string]interface{}{
                "session_id":  sessionID,
                "item_id":     itemID,
                "highest_bid": highest,
                "bidder_id":   bidder,
        }

        return utils.SuccessResponse(c, "highest bid retrieved successfully", resp)</span>
}

// SyncHighestBid godoc
// @Summary Sync highest bid to database
// @Description Synchronize the highest bid from Redis cache to the database
// @Tags Your Donate Rise API - Bidding
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param sessionID path int true "Auction Session ID"
// @Param itemID path int true "Auction Item ID"
// @Success 200 {object} utils.Response "Highest bid synced to database"
// @Failure 400 {object} utils.Response "Bad request - Invalid session or item ID"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Admin access required"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auction/sessions/{sessionID}/items/{itemID}/sync [post]
func (h *BidController) SyncHighestBid(c echo.Context) error <span class="cov0" title="0">{
        if !isAdminFromToken(c) </span><span class="cov0" title="0">{
                return utils.ForbiddenResponse(c, "only admin can sync bids")
        }</span>

        <span class="cov0" title="0">sessionIDStr := c.Param("sessionID")
        itemIDStr := c.Param("itemID")

        sessionID, err := strconv.ParseInt(sessionIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid sessionID")
        }</span>

        <span class="cov0" title="0">itemID, err := strconv.ParseInt(itemIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid itemID")
        }</span>

        <span class="cov0" title="0">err = h.svc.SyncHighestBid(sessionID, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">return utils.SuccessResponse(c, "highest bid synced to database", nil)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package controller

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "milestone3/be/internal/dto"
        "milestone3/be/internal/entity"
        "milestone3/be/internal/repository"
        "milestone3/be/internal/service"
        "milestone3/be/internal/utils"

        "github.com/labstack/echo/v4"
)

type DonationController struct {
        svc          service.DonationService
        privateStore repository.GCPStorageRepo
}

func NewDonationController(s service.DonationService, privateStore repository.GCPStorageRepo) *DonationController <span class="cov0" title="0">{
        return &amp;DonationController{svc: s, privateStore: privateStore}
}</span>

// CreateDonation godoc
// @Summary Create new donation
// @Description Submit a new donation with photos and details
// @Tags Your Donate Rise API - Donations
// @Accept multipart/form-data
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param title formData string true "Donation title"
// @Param description formData string true "Donation description"
// @Param category formData string true "Donation category"
// @Param condition formData string true "Item condition"
// @Param photos formData file false "Donation photos (multiple files allowed)"
// @Success 201 {object} utils.Response "Donation created successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payload or file upload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /donations [post]
func (h *DonationController) CreateDonation(c echo.Context) error <span class="cov0" title="0">{
        var payload dto.DonationDTO

        contentType := c.Request().Header.Get("Content-Type")
        if strings.HasPrefix(contentType, "multipart/form-data") </span><span class="cov0" title="0">{

                if err := c.Request().ParseMultipartForm(32 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                        return utils.BadRequestResponse(c, "invalid multipart form")
                }</span>
                <span class="cov0" title="0">form := c.Request().MultipartForm

                payload.Title = form.Value["title"][0]
                payload.Description = form.Value["description"][0]
                payload.Category = form.Value["category"][0]
                payload.Condition = form.Value["condition"][0]

                if v, ok := form.Value["status"]; ok </span><span class="cov0" title="0">{
                        payload.Status = entity.StatusDonation(v[0])
                }</span>

                // FILE HANDLING PRIVATE ONLY
                <span class="cov0" title="0">if fhs, ok := form.File["photos"]; ok </span><span class="cov0" title="0">{
                        for _, fh := range fhs </span><span class="cov0" title="0">{
                                f, err := fh.Open()
                                if err != nil </span><span class="cov0" title="0">{
                                        return utils.BadRequestResponse(c, "cannot open file")
                                }</span>

                                <span class="cov0" title="0">objName := fmt.Sprintf("donations/private/%d_%s", time.Now().UnixNano(), fh.Filename)
                                objectName, err := h.privateStore.UploadFile(c.Request().Context(), f, objName)
                                _ = f.Close()

                                if err != nil </span><span class="cov0" title="0">{
                                        return utils.InternalServerErrorResponse(c, "failed upload")
                                }</span>

                                // SAVE PRIVATE STORAGE (objectName)
                                <span class="cov0" title="0">payload.Photos = append(payload.Photos, objectName)</span>
                        }
                }

        } else<span class="cov0" title="0"> {
                if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                        return utils.BadRequestResponse(c, "invalid payload")
                }</span>
        }

        <span class="cov0" title="0">userID, ok := utils.GetUserID(c)
        if !ok || userID == 0 </span><span class="cov0" title="0">{
                return utils.UnauthorizedResponse(c, "unauthenticated")
        }</span>
        <span class="cov0" title="0">payload.UserID = userID

        if err := h.svc.CreateDonation(payload); err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed creating donation")
        }</span>

        <span class="cov0" title="0">return utils.CreatedResponse(c, "donation created successfully", nil)</span>
}

// GetAllDonations godoc
// @Summary Get all donations
// @Description Get all donations (admin sees all, users see only their own)
// @Tags Your Donate Rise API - Donations
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} utils.Response "Donations retrieved successfully"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /donations [get]
func (h *DonationController) GetAllDonations(c echo.Context) error <span class="cov0" title="0">{
        userID, _ := utils.GetUserID(c) // unauthenticated =&gt; 0,false
        isAdm := utils.IsAdmin(c)

        // require auth for user-level listing; admin may call even without user_id set by middleware
        if !isAdm </span><span class="cov0" title="0">{
                if userID == 0 </span><span class="cov0" title="0">{
                        return utils.UnauthorizedResponse(c, "unauthenticated")
                }</span>
        }

        <span class="cov0" title="0">donations, err := h.svc.GetAllDonations(userID, isAdm)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "failed fetching donations")
        }</span>
        <span class="cov0" title="0">return utils.SuccessResponse(c, "donations fetched", donations)</span>
}

// GetDonationByID godoc
// @Summary Get donation by ID
// @Description Retrieve a specific donation by ID (owner or admin only)
// @Tags Your Donate Rise API - Donations
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Donation ID"
// @Success 200 {object} utils.Response "Donation retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid donation ID"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Access denied"
// @Failure 404 {object} utils.Response "Donation not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /donations/{id} [get]
func (h *DonationController) GetDonationByID(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>

        <span class="cov0" title="0">d, err := h.svc.GetDonationByID(uint(id64))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrDonationNotFound) </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "donation not found")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed fetching donation")</span>
        }

        // permission check: owner or admin
        <span class="cov0" title="0">if !utils.IsAdmin(c) </span><span class="cov0" title="0">{
                userID, ok := utils.GetUserID(c)
                if !ok </span><span class="cov0" title="0">{
                        return utils.UnauthorizedResponse(c, "unauthenticated")
                }</span>
                <span class="cov0" title="0">if d.UserID != userID </span><span class="cov0" title="0">{
                        return utils.ForbiddenResponse(c, "forbidden")
                }</span>
        }

        <span class="cov0" title="0">return utils.SuccessResponse(c, "donation fetched", d)</span>
}

// UpdateDonation godoc
// @Summary Update donation
// @Description Update an existing donation (owner or admin only)
// @Tags Your Donate Rise API - Donations
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Donation ID"
// @Param donation body object true "Updated donation data"
// @Success 200 {object} utils.Response "Donation updated successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID or payload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Access denied"
// @Failure 404 {object} utils.Response "Donation not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /donations/{id} [put]
func (h *DonationController) UpdateDonation(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>

        <span class="cov0" title="0">var payload dto.DonationDTO
        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>
        <span class="cov0" title="0">payload.ID = uint(id64)

        userID, ok := utils.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                return utils.UnauthorizedResponse(c, "unauthenticated")
        }</span>
        <span class="cov0" title="0">isAdm := utils.IsAdmin(c)

        if err := h.svc.UpdateDonation(payload, userID, isAdm); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrDonationNotFound) </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "donation not found")
                }</span>
                <span class="cov0" title="0">if errors.Is(err, service.ErrForbidden) </span><span class="cov0" title="0">{
                        return utils.ForbiddenResponse(c, "forbidden")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed updating donation")</span>
        }
        <span class="cov0" title="0">return utils.SuccessResponse(c, "donation updated", nil)</span>
}

// DeleteDonation godoc
// @Summary Delete donation
// @Description Delete a donation by ID (owner or admin only)
// @Tags Your Donate Rise API - Donations
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Donation ID"
// @Success 204 "Donation deleted successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid donation ID"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Access denied"
// @Failure 404 {object} utils.Response "Donation not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /donations/{id} [delete]
func (h *DonationController) DeleteDonation(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>

        <span class="cov0" title="0">userID, ok := utils.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                return utils.UnauthorizedResponse(c, "unauthenticated")
        }</span>
        <span class="cov0" title="0">isAdm := utils.IsAdmin(c)

        if err := h.svc.DeleteDonation(uint(id64), userID, isAdm); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrDonationNotFound) </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "donation not found")
                }</span>
                <span class="cov0" title="0">if errors.Is(err, service.ErrForbidden) </span><span class="cov0" title="0">{
                        return utils.ForbiddenResponse(c, "forbidden")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed deleting donation")</span>
        }
        <span class="cov0" title="0">return utils.NoContentResponse(c)</span>
}

// PatchDonation godoc
// @Summary Partially update donation
// @Description Partially update a donation by ID (owner or admin only)
// @Tags Your Donate Rise API - Donations
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "Donation ID"
// @Param donation body object true "Partial donation data"
// @Success 200 {object} utils.Response "Donation patched successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid ID or payload"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 403 {object} utils.Response "Forbidden - Access denied"
// @Failure 404 {object} utils.Response "Donation not found"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /donations/{id} [patch]
func (h *DonationController) PatchDonation(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id64, err := strconv.ParseUint(idParam, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid id")
        }</span>

        <span class="cov0" title="0">var payload dto.DonationDTO
        if err := c.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "invalid payload")
        }</span>
        <span class="cov0" title="0">payload.ID = uint(id64)

        userID, ok := utils.GetUserID(c)
        if !ok </span><span class="cov0" title="0">{
                return utils.UnauthorizedResponse(c, "unauthenticated")
        }</span>
        <span class="cov0" title="0">isAdm := utils.IsAdmin(c)

        if err := h.svc.PatchDonation(payload, userID, isAdm); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrDonationNotFound) </span><span class="cov0" title="0">{
                        return utils.NotFoundResponse(c, "donation not found")
                }</span>
                <span class="cov0" title="0">if errors.Is(err, service.ErrForbidden) </span><span class="cov0" title="0">{
                        return utils.ForbiddenResponse(c, "forbidden")
                }</span>
                <span class="cov0" title="0">return utils.InternalServerErrorResponse(c, "failed patching donation")</span>
        }
        <span class="cov0" title="0">return utils.SuccessResponse(c, "donation patched", nil)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package controller

import (
        "milestone3/be/internal/service"
        "milestone3/be/internal/utils"
        "strconv"

        "github.com/labstack/echo/v4"
)

type FinalDonationController struct {
        svc service.FinalDonationService
}

func NewFinalDonationController(finalDonationService service.FinalDonationService) *FinalDonationController <span class="cov0" title="0">{
        return &amp;FinalDonationController{svc: finalDonationService}
}</span>

// GetAllFinalDonations godoc
// @Summary Get all final donations
// @Description Retrieve all items that were directly donated to institutions
// @Tags Your Donate Rise API - Final Donations
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response "Final donations retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Failed to fetch final donations"
// @Router /donations/final [get]
func (h *FinalDonationController) GetAllFinalDonations(c echo.Context) error <span class="cov0" title="0">{
        finalDonations, err := h.svc.GetAllFinalDonations()
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "Failed to fetch final donations")
        }</span>
        <span class="cov0" title="0">return utils.SuccessResponse(c, "Final donations fetched successfully", finalDonations)</span>
}
// GetAllFinalDonationsByUserID godoc
// @Summary Get final donations by user ID
// @Description Retrieve all final donations made by a specific user
// @Tags Your Donate Rise API - Final Donations
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Success 200 {object} utils.Response "Final donations retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid user ID or failed to fetch"
// @Router /donations/final/user/{user_id} [get]
func (h *FinalDonationController) GetAllFinalDonationsByUserID(c echo.Context) error <span class="cov0" title="0">{
        userIDStr := c.Param("user_id")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "Invalid user id")
        }</span>
        <span class="cov0" title="0">finalDonations, err := h.svc.GetAllFinalDonationsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, "Failed to fetch final donations for the user")
        }</span>
        <span class="cov0" title="0">return utils.SuccessResponse(c, "Final donations fetched successfully", finalDonations)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package controller

import (
        "milestone3/be/internal/dto"
        "milestone3/be/internal/utils"
        "strconv"

        "github.com/go-playground/validator/v10"
        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type PaymentService interface {
        CreatePayment(req dto.PaymentRequest, userId int, auctionItemId int) (res dto.PaymentResponse, err error)
        CheckPaymentStatusMidtrans(orderId string) (res dto.CheckPaymentStatusResponse, err error)
        GetPaymentById(id int) (res dto.PaymentInfoResponse, err error)
        GetAllPayment() (res []dto.PaymentInfoResponse, err error)
}

type PaymentController struct {
        paymentService PaymentService
        validate *validator.Validate
}

func NewPaymentController(validate *validator.Validate, ps PaymentService) *PaymentController <span class="cov8" title="1">{
        return &amp;PaymentController{paymentService:ps, validate: validate}
}</span>

// CreatePayment godoc
// @Summary Create payment for auction item
// @Description Create a payment transaction for a won auction item
// @Tags Your Donate Rise API - Payments
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param auctionId path int true "Auction Item ID"
// @Param payment body object true "Payment details"
// @Success 201 {object} utils.Response "Payment created successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payload or auction ID"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid or missing token"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /payments/auction/{auctionId} [post]
func (pc *PaymentController) CreatePayment(c echo.Context) error <span class="cov8" title="1">{
        user := c.Get("user").(*jwt.Token)
        claim := user.Claims.(jwt.MapClaims)
        userId := int(claim["id"].(float64))
        req := new(dto.PaymentRequest)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov8" title="1">if err := pc.validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov8" title="1">auctionIdStr := c.Param("auctionId")
        auctionId, err := strconv.Atoi(auctionIdStr)
        if err != nil </span><span class="cov8" title="1">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov8" title="1">resp, err := pc.paymentService.CreatePayment(*req, userId, auctionId)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov8" title="1">return utils.CreatedResponse(c, "create", resp)</span>
}

// CheckPaymentStatusMidtrans godoc
// @Summary Check payment status via Midtrans
// @Description Check the payment status of an order through Midtrans payment gateway
// @Tags Your Donate Rise API - Payments
// @Accept json
// @Produce json
// @Param id path string true "Order ID"
// @Success 200 {object} utils.Response "Payment status retrieved successfully"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /payments/status/{id} [get]
func (pc *PaymentController) CheckPaymentStatusMidtrans(c echo.Context) error <span class="cov0" title="0">{
        orderId := c.Param("id")
        resp, err := pc.paymentService.CheckPaymentStatusMidtrans(orderId)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov0" title="0">return utils.SuccessResponse(c, "ok", resp)</span>
}

// GetPaymentById godoc
// @Summary Get payment by ID
// @Description Retrieve payment information by payment ID
// @Tags Your Donate Rise API - Payments
// @Accept json
// @Produce json
// @Param id path int true "Payment ID"
// @Success 200 {object} utils.Response "Payment retrieved successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payment ID"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /payments/{id} [get]
func (pc *PaymentController) GetPaymentById(c echo.Context) error <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">resp, err := pc.paymentService.GetPaymentById(id)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov0" title="0">return utils.SuccessResponse(c, "ok", resp)</span>
}

// GetAllPayment godoc
// @Summary Get all payments
// @Description Retrieve all payment transactions in the system
// @Tags Your Donate Rise API - Payments
// @Accept json
// @Produce json
// @Success 200 {object} utils.Response "Payments retrieved successfully"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /payments [get]
func (pc *PaymentController) GetAllPayment(c echo.Context) error <span class="cov8" title="1">{
        resp, err := pc.paymentService.GetAllPayment()
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov8" title="1">return utils.SuccessResponse(c, "ok", resp)</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package controller

import (
        "milestone3/be/internal/dto"
        "milestone3/be/internal/utils"

        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"
)

type UserService interface {
        CreateUser(req dto.UserRequest) (res dto.UserResponse, err error)
        GetUserByEmail(email, password string) (accessToken string, err error)
}

type UserController struct {
        userService UserService
        validate *validator.Validate
}

func NewUserController(validate *validator.Validate, us UserService) *UserController <span class="cov0" title="0">{
        return &amp;UserController{validate: validate, userService: us}
}</span>

// CreateUser godoc
// @Summary Register new user
// @Description Register a new user account in the system
// @Tags Your Donate Rise API - Authentication
// @Accept json
// @Produce json
// @Param user body object true "User registration data"
// @Success 201 {object} utils.Response "User created successfully"
// @Failure 400 {object} utils.Response "Bad request - Invalid payload or validation error"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auth/register [post]
func (uc *UserController) CreateUser(c echo.Context) error <span class="cov0" title="0">{
        req := new(dto.UserRequest)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">if err := uc.validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">resp, err := uc.userService.CreateUser(*req)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov0" title="0">return utils.CreatedResponse(c, "user created", resp)</span>
}

// LoginUser godoc
// @Summary User login
// @Description Authenticate user and return access token
// @Tags Your Donate Rise API - Authentication
// @Accept json
// @Produce json
// @Param credentials body object true "User login credentials"
// @Success 200 {object} utils.Response "Login successful, returns access token"
// @Failure 400 {object} utils.Response "Bad request - Invalid credentials format"
// @Failure 401 {object} utils.Response "Unauthorized - Invalid email or password"
// @Failure 500 {object} utils.Response "Internal server error"
// @Router /auth/login [post]
func (uc *UserController) LoginUser(c echo.Context) error <span class="cov0" title="0">{
        req := new(dto.UserLoginRequest)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">if err := uc.validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                return utils.BadRequestResponse(c, err.Error())
        }</span>

        <span class="cov0" title="0">resp, err := uc.userService.GetUserByEmail(req.Email, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return utils.InternalServerErrorResponse(c, "internal server error")
        }</span>

        <span class="cov0" title="0">return utils.SuccessResponse(c, "success login", resp)</span>
}</pre>
		
		<pre class="file" id="file26" style="display: none">package dto

import (
        "milestone3/be/internal/entity"
        "time"
)

type ArticleDTO struct {
        ID        uint      `json:"id,omitempty" validate:"omitempty"`
        Title     string    `json:"title,omitempty" validate:"required"`
        Content   string    `json:"content,omitempty" validate:"required"`
        Week      int       `json:"week,omitempty" validate:"required"`
        Image     string    `json:"image,omitempty" validate:"omitempty"`
        CreatedAt time.Time `json:"created_at,omitempty"`
}

// ArticleRequest converts DTO to entity.Article
func ArticleRequest(a ArticleDTO) (entity.Article, error) <span class="cov0" title="0">{
        return entity.Article{
                ID:        a.ID,
                Title:     a.Title,
                Content:   a.Content,
                Week:      a.Week,
                Image:     a.Image,
                CreatedAt: a.CreatedAt,
        }, nil
}</span>

// ArticleResponse converts entity.Article to DTO
func ArticleResponse(m entity.Article) ArticleDTO <span class="cov0" title="0">{
        return ArticleDTO{
                ID:        m.ID,
                Title:     m.Title,
                Content:   m.Content,
                Week:      m.Week,
                Image:     m.Image,
                CreatedAt: m.CreatedAt,
        }
}</span>

// ArticleResponses converts slice of entity.Article to slice of DTOs
func ArticleResponses(articles []entity.Article) []ArticleDTO <span class="cov0" title="0">{
        dtos := make([]ArticleDTO, len(articles))
        for i, article := range articles </span><span class="cov0" title="0">{
                dtos[i] = ArticleResponse(article)
        }</span>
        <span class="cov0" title="0">return dtos</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package dto

import (
        "time"

        "milestone3/be/internal/entity"
)

type AuctionItemDTO struct {
        Title         string  `json:"title,omitempty" validate:"required"`
        Description   string  `json:"description,omitempty" validate:"required"`
        Category      string  `json:"category,omitempty" validate:"required"`
        Status        string  `json:"status,omitempty"`
        ID            int64   `json:"id,omitempty" validate:"omitempty"`
        UserID        int64   `json:"user_id,omitempty"`
        DonationID    int64   `json:"donation_id,omitempty" validate:"required"`
        SessionID     *int64  `json:"session_id,omitempty"`
        StartingPrice float64 `json:"starting_price,omitempty"`
        // Photos        []string  `json:"photos,omitempty" validate:"dive,url"`
        CreatedAt time.Time `json:"created_at,omitempty"`
}

func AuctionItemRequest(d AuctionItemDTO) (entity.AuctionItem, error) <span class="cov0" title="0">{
        // photos := make([]entity.DonationPhoto, 0, len(d.Photos))
        // for _, u := range d.Photos {
        //         photos = append(photos, entity.DonationPhoto{URL: u, DonationID: uint(d.DonationID)})
        // }

        status := d.Status
        if status == "" </span><span class="cov0" title="0">{
                status = "scheduled"
        }</span>

        <span class="cov0" title="0">return entity.AuctionItem{
                ID:            d.ID,
                DonationID:    d.DonationID,
                SessionID:     d.SessionID,
                Title:         d.Title,
                Description:   d.Description,
                Category:      d.Category,
                Status:        status,
                StartingPrice: d.StartingPrice,
                CreatedAt:     d.CreatedAt,
                // Photos:        photos,
        }, nil</span>
}

func AuctionItemResponse(m entity.AuctionItem) AuctionItemDTO <span class="cov0" title="0">{
        // photos := make([]string, 0, len(m.Photos))
        // for _, p := range m.Photos {
        //         photos = append(photos, p.URL)
        // }

        return AuctionItemDTO{
                ID:            m.ID,
                DonationID:    m.DonationID,
                SessionID:     m.SessionID,
                Title:         m.Title,
                Description:   m.Description,
                Category:      m.Category,
                Status:        m.Status,
                StartingPrice: m.StartingPrice,
                // Photos:        photos,
                CreatedAt: m.CreatedAt,
        }
}</span>

func AuctionItemResponses(ms []entity.AuctionItem) []AuctionItemDTO <span class="cov0" title="0">{
        res := make([]AuctionItemDTO, 0, len(ms))
        for _, m := range ms </span><span class="cov0" title="0">{
                res = append(res, AuctionItemResponse(m))
        }</span>
        <span class="cov0" title="0">return res</span>
}

type AuctionSessionDTO struct {
        Name      string    `json:"name,omitempty" validate:"required"`
        ID        int       `json:"id,omitempty"`
        StartTime time.Time `json:"start_time,omitempty" validate:"required"`
        EndTime   time.Time `json:"end_time,omitempty" validate:"required"`
}

func AuctionSessionResponse(m entity.AuctionSession) AuctionSessionDTO <span class="cov0" title="0">{
        return AuctionSessionDTO{
                Name:      m.Name,
                ID:        int(m.ID),
                StartTime: m.StartTime,
                EndTime:   m.EndTime,
        }
}</span>

func AuctionSessionResponses(ms []entity.AuctionSession) []AuctionSessionDTO <span class="cov0" title="0">{
        res := make([]AuctionSessionDTO, 0, len(ms))
        for _, m := range ms </span><span class="cov0" title="0">{
                res = append(res, AuctionSessionResponse(m))
        }</span>
        <span class="cov0" title="0">return res</span>
}

func AuctionSessionRequest(d AuctionSessionDTO) entity.AuctionSession <span class="cov0" title="0">{
        return entity.AuctionSession{
                Name:      d.Name,
                StartTime: d.StartTime,
                EndTime:   d.EndTime,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package dto

import (
        "milestone3/be/internal/entity"
)

type BidDTO struct {
        Amount float64 `json:"amount" validate:"required,gt=0"`
}

func BidRequest(d BidDTO) entity.Bid <span class="cov0" title="0">{
        return entity.Bid{
                Amount: d.Amount,
        }
}</span>

func BidResponse(m entity.Bid) BidDTO <span class="cov0" title="0">{
        return BidDTO{
                Amount: m.Amount,
        }
}</span>

func BidResponses(ms []entity.Bid) []BidDTO <span class="cov0" title="0">{
        res := make([]BidDTO, 0, len(ms))
        for _, m := range ms </span><span class="cov0" title="0">{
                res = append(res, BidResponse(m))
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package dto

import (
        "time"

        "milestone3/be/internal/entity"
)

type DonationDTO struct {
        ID          uint                  `json:"id,omitempty" validate:"omitempty"`
        UserID      uint                  `json:"user_id,omitempty" validate:"required"`
        Title       string                `json:"title,omitempty" validate:"required"`
        Description string                `json:"description,omitempty" validate:"required"`
        Category    string                `json:"category,omitempty" validate:"required"`
        Condition   string                `json:"condition,omitempty" validate:"required"`
        Status      entity.StatusDonation `json:"status,omitempty" validate:"required"`
        Photos      []string              `json:"photos,omitempty" validate:"dive,url"`
        CreatedAt   time.Time             `json:"created_at,omitempty"`
}

// DonationRequest converts DTO to entity.Donation
func DonationRequest(d DonationDTO) (entity.Donation, error) <span class="cov0" title="0">{
        photos := make([]entity.DonationPhoto, 0, len(d.Photos))
        for _, u := range d.Photos </span><span class="cov0" title="0">{
                photos = append(photos, entity.DonationPhoto{URL: u})
        }</span>
        <span class="cov0" title="0">return entity.Donation{
                ID:          d.ID,
                UserID:      d.UserID,
                Title:       d.Title,
                Description: d.Description,
                Category:    d.Category,
                Condition:   d.Condition,
                Status:      d.Status,
                CreatedAt:   d.CreatedAt,
                Photos:      photos,
        }, nil</span>
}

// DonationResponse converts entity.Donation to DTO
func DonationResponse(m entity.Donation) DonationDTO <span class="cov0" title="0">{
        photos := make([]string, 0, len(m.Photos))
        for _, p := range m.Photos </span><span class="cov0" title="0">{
                photos = append(photos, p.URL)
        }</span>
        <span class="cov0" title="0">return DonationDTO{
                ID:          m.ID,
                UserID:      m.UserID,
                Title:       m.Title,
                Description: m.Description,
                Category:    m.Category,
                Condition:   m.Condition,
                Status:      m.Status,
                Photos:      photos,
                CreatedAt:   m.CreatedAt,
        }</span>
}

// DonationResponses converts slice of entity.Donation to slice of DTOs
func DonationResponses(ms []entity.Donation) []DonationDTO <span class="cov0" title="0">{
        res := make([]DonationDTO, 0, len(ms))
        for _, m := range ms </span><span class="cov0" title="0">{
                res = append(res, DonationResponse(m))
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/service/payment_service.go

// Package mocks is a generated GoMock package.
package mocks

import (
        dto "milestone3/be/internal/dto"
        entity "milestone3/be/internal/entity"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockPaymentRepository is a mock of PaymentRepository interface.
type MockPaymentRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPaymentRepositoryMockRecorder
}

// MockPaymentRepositoryMockRecorder is the mock recorder for MockPaymentRepository.
type MockPaymentRepositoryMockRecorder struct {
        mock *MockPaymentRepository
}

// NewMockPaymentRepository creates a new mock instance.
func NewMockPaymentRepository(ctrl *gomock.Controller) *MockPaymentRepository <span class="cov0" title="0">{
        mock := &amp;MockPaymentRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPaymentRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPaymentRepository) EXPECT() *MockPaymentRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CheckPaymentStatusMidtrans mocks base method.
func (m *MockPaymentRepository) CheckPaymentStatusMidtrans(orderId string) (dto.CheckPaymentStatusResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckPaymentStatusMidtrans", orderId)
        ret0, _ := ret[0].(dto.CheckPaymentStatusResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckPaymentStatusMidtrans indicates an expected call of CheckPaymentStatusMidtrans.
func (mr *MockPaymentRepositoryMockRecorder) CheckPaymentStatusMidtrans(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckPaymentStatusMidtrans", reflect.TypeOf((*MockPaymentRepository)(nil).CheckPaymentStatusMidtrans), orderId)
}</span>

// Create mocks base method.
func (m *MockPaymentRepository) Create(payment *entity.Payment, orderId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", payment, orderId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPaymentRepositoryMockRecorder) Create(payment, orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPaymentRepository)(nil).Create), payment, orderId)
}</span>

// CreateMidtrans mocks base method.
func (m *MockPaymentRepository) CreateMidtrans(payment entity.Payment, orderId string) (dto.PaymentResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateMidtrans", payment, orderId)
        ret0, _ := ret[0].(dto.PaymentResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateMidtrans indicates an expected call of CreateMidtrans.
func (mr *MockPaymentRepositoryMockRecorder) CreateMidtrans(payment, orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMidtrans", reflect.TypeOf((*MockPaymentRepository)(nil).CreateMidtrans), payment, orderId)
}</span>

// GetAll mocks base method.
func (m *MockPaymentRepository) GetAll() ([]entity.Payment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll")
        ret0, _ := ret[0].([]entity.Payment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockPaymentRepositoryMockRecorder) GetAll() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockPaymentRepository)(nil).GetAll))
}</span>

// GetById mocks base method.
func (m *MockPaymentRepository) GetById(id int) (entity.Payment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetById", id)
        ret0, _ := ret[0].(entity.Payment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetById indicates an expected call of GetById.
func (mr *MockPaymentRepositoryMockRecorder) GetById(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetById", reflect.TypeOf((*MockPaymentRepository)(nil).GetById), id)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/controller/payment_controller.go

// Package mocks is a generated GoMock package.
package mocks

import (
        dto "milestone3/be/internal/dto"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockPaymentService is a mock of PaymentService interface.
type MockPaymentService struct {
        ctrl     *gomock.Controller
        recorder *MockPaymentServiceMockRecorder
}

// MockPaymentServiceMockRecorder is the mock recorder for MockPaymentService.
type MockPaymentServiceMockRecorder struct {
        mock *MockPaymentService
}

// NewMockPaymentService creates a new mock instance.
func NewMockPaymentService(ctrl *gomock.Controller) *MockPaymentService <span class="cov0" title="0">{
        mock := &amp;MockPaymentService{ctrl: ctrl}
        mock.recorder = &amp;MockPaymentServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPaymentService) EXPECT() *MockPaymentServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CheckPaymentStatusMidtrans mocks base method.
func (m *MockPaymentService) CheckPaymentStatusMidtrans(orderId string) (dto.CheckPaymentStatusResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckPaymentStatusMidtrans", orderId)
        ret0, _ := ret[0].(dto.CheckPaymentStatusResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckPaymentStatusMidtrans indicates an expected call of CheckPaymentStatusMidtrans.
func (mr *MockPaymentServiceMockRecorder) CheckPaymentStatusMidtrans(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckPaymentStatusMidtrans", reflect.TypeOf((*MockPaymentService)(nil).CheckPaymentStatusMidtrans), orderId)
}</span>

// CreatePayment mocks base method.
func (m *MockPaymentService) CreatePayment(req dto.PaymentRequest, userId, auctionItemId int) (dto.PaymentResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePayment", req, userId, auctionItemId)
        ret0, _ := ret[0].(dto.PaymentResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreatePayment indicates an expected call of CreatePayment.
func (mr *MockPaymentServiceMockRecorder) CreatePayment(req, userId, auctionItemId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePayment", reflect.TypeOf((*MockPaymentService)(nil).CreatePayment), req, userId, auctionItemId)
}</span>

// GetAllPayment mocks base method.
func (m *MockPaymentService) GetAllPayment() ([]dto.PaymentInfoResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllPayment")
        ret0, _ := ret[0].([]dto.PaymentInfoResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllPayment indicates an expected call of GetAllPayment.
func (mr *MockPaymentServiceMockRecorder) GetAllPayment() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllPayment", reflect.TypeOf((*MockPaymentService)(nil).GetAllPayment))
}</span>

// GetPaymentById mocks base method.
func (m *MockPaymentService) GetPaymentById(id int) (dto.PaymentInfoResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPaymentById", id)
        ret0, _ := ret[0].(dto.PaymentInfoResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPaymentById indicates an expected call of GetPaymentById.
func (mr *MockPaymentServiceMockRecorder) GetPaymentById(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPaymentById", reflect.TypeOf((*MockPaymentService)(nil).GetPaymentById), id)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/service/user_service.go

// Package mocks is a generated GoMock package.
package mocks

import (
        entity "milestone3/be/internal/entity"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(user *entity.Users) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), user)
}</span>

// GetByEmail mocks base method.
func (m *MockUserRepository) GetByEmail(email string) (entity.Users, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByEmail", email)
        ret0, _ := ret[0].(entity.Users)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByEmail indicates an expected call of GetByEmail.
func (mr *MockUserRepositoryMockRecorder) GetByEmail(email interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByEmail", reflect.TypeOf((*MockUserRepository)(nil).GetByEmail), email)
}</span>

// GetById mocks base method.
func (m *MockUserRepository) GetById(id int) (entity.Users, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetById", id)
        ret0, _ := ret[0].(entity.Users)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetById indicates an expected call of GetById.
func (mr *MockUserRepositoryMockRecorder) GetById(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetById", reflect.TypeOf((*MockUserRepository)(nil).GetById), id)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/controller/user_controller.go

// Package mocks is a generated GoMock package.
package mocks

import (
        dto "milestone3/be/internal/dto"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov0" title="0">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserService) CreateUser(req dto.UserRequest) (dto.UserResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", req)
        ret0, _ := ret[0].(dto.UserResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserServiceMockRecorder) CreateUser(req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserService)(nil).CreateUser), req)
}</span>

// GetUserByEmail mocks base method.
func (m *MockUserService) GetUserByEmail(email, password string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByEmail", email, password)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByEmail indicates an expected call of GetUserByEmail.
func (mr *MockUserServiceMockRecorder) GetUserByEmail(email, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByEmail", reflect.TypeOf((*MockUserService)(nil).GetUserByEmail), email, password)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "context"
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type AdminRepo struct {
        db *gorm.DB
        ctx context.Context
}

func NewAdminRepository(db *gorm.DB, ctx context.Context) *AdminRepo <span class="cov0" title="0">{
        return &amp;AdminRepo{db: db, ctx: ctx}
}</span>


//count total transaction
func (ar *AdminRepo) CountPayment() (count int64, err error) <span class="cov0" title="0">{
        var payment entity.Payment
        if err := ar.db.WithContext(ar.ctx).Model(&amp;payment).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
 
// //count total donation
func (ar *AdminRepo) CountDonation() (count int64, err error) <span class="cov0" title="0">{
        var donation entity.Donation
        if err := ar.db.WithContext(ar.ctx).Model(&amp;donation).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// count total auction
// work in progress (WIP)
func (ar *AdminRepo) CountAuction() (count int64, err error) <span class="cov0" title="0">{
        var auction entity.AuctionItem
        if err := ar.db.WithContext(ar.ctx).Model(&amp;auction).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                        return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// //count total article
func (ar *AdminRepo) CountArticle() (count int64, err error) <span class="cov0" title="0">{
        var article entity.Article
        if err := ar.db.WithContext(ar.ctx).Model(&amp;article).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// for reporting endpoint //
// work in progress (WIP)</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "strings"
        "time"
)

type AIRepository interface {
        EstimateStartingPrice(req PriceEstimationRequest) (float64, error)
}

type aiRepo struct {
        logger       *slog.Logger
        GeminiAPIKey string
        httpClient   *http.Client
}

func NewAIRepository(logger *slog.Logger, geminiAPIKey string) AIRepository <span class="cov0" title="0">{
        return &amp;aiRepo{
                logger:       logger,
                GeminiAPIKey: geminiAPIKey,
                httpClient:   &amp;http.Client{Timeout: 15 * time.Second},
        }
}</span>

type PriceEstimationRequest struct {
        Name        string `json:"name"`
        Category    string `json:"category"`
        Condition   string `json:"condition"`
        Description string `json:"description"`
}

type geminiRespBody struct {
        Candidates []struct {
                Content struct {
                        Parts []struct {
                                Text string `json:"text"`
                        } `json:"parts"`
                } `json:"content"`
        } `json:"candidates"`
}

func (r *aiRepo) EstimateStartingPrice(req PriceEstimationRequest) (float64, error) <span class="cov0" title="0">{
        price, err := r.callGeminiModel(req, "gemini-2.5-flash")
        if err == nil </span><span class="cov0" title="0">{
                return price, nil
        }</span>
        <span class="cov0" title="0">r.logger.Error("Gemini failed completely, manual input for starting price", "error", err)

        return 10000, errors.New("all AI models failed, manual price needed")</span>
}

func (r *aiRepo) callGeminiModel(req PriceEstimationRequest, model string) (float64, error) <span class="cov0" title="0">{
        url := fmt.Sprintf(
                "https://generativelanguage.googleapis.com/v1beta/models/%s:generateContent",
                model,
        )

        prompt := fmt.Sprintf(`
                Anda adalah AI untuk menentukan start price lelang barang.

                Kembalikan JSON saja:
                { "starting_price": 123456 }

                Nama: %s
                Kategori: %s
                Kondisi: %s
                Deskripsi: %s
                `, req.Name, req.Category, req.Condition, req.Description)

        payload := map[string]interface{}{
                "contents": []map[string]interface{}{
                        {"parts": []map[string]string{{"text": prompt}}},
                },
                "generationConfig": map[string]interface{}{
                        "responseMimeType": "application/json",
                        "responseJsonSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "starting_price": map[string]interface{}{"type": "integer"},
                                },
                                "required": []string{"starting_price"},
                        },
                },
        }

        body, _ := json.Marshal(payload)
        reqHTTP, _ := http.NewRequest(http.MethodPost, url, strings.NewReader(string(body)))
        reqHTTP.Header.Set("x-goog-api-key", r.GeminiAPIKey)
        reqHTTP.Header.Set("Content-Type", "application/json")

        resp, err := r.httpClient.Do(reqHTTP)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBytes, _ := io.ReadAll(resp.Body)
        var data geminiRespBody
        if err := json.Unmarshal(respBytes, &amp;data); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if len(data.Candidates) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("no AI response")
        }</span>

        <span class="cov0" title="0">raw := strings.TrimSpace(data.Candidates[0].Content.Parts[0].Text)
        var result struct {
                StartingPrice float64 `json:"starting_price"`
        }

        if err := json.Unmarshal([]byte(raw), &amp;result); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid AI JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return result.StartingPrice, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type ArticleRepo interface {
        GetAllArticles() ([]entity.Article, error)
        GetArticleByID(id uint) (entity.Article, error)
        // Admin functionalities
        CreateArticle(article entity.Article) error
        UpdateArticle(article entity.Article) error
        DeleteArticle(id uint) error
}

type articleRepo struct {
        db *gorm.DB
}

func NewArticleRepo(db *gorm.DB) ArticleRepo <span class="cov0" title="0">{
        return &amp;articleRepo{db: db}
}</span>

func (r *articleRepo) CreateArticle(article entity.Article) error <span class="cov0" title="0">{
        return r.db.Create(&amp;article).Error
}</span>

func (r *articleRepo) GetAllArticles() ([]entity.Article, error) <span class="cov0" title="0">{
        var articles []entity.Article
        err := r.db.Find(&amp;articles).Error
        return articles, err
}</span>

func (r *articleRepo) GetArticleByID(id uint) (entity.Article, error) <span class="cov0" title="0">{
        var article entity.Article
        err := r.db.First(&amp;article, id).Error
        return article, err
}</span>

func (r *articleRepo) UpdateArticle(article entity.Article) error <span class="cov0" title="0">{
        return r.db.Save(&amp;article).Error
}</span>

func (r *articleRepo) DeleteArticle(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entity.Article{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type AuctionItemRepository interface {
        Create(item *entity.AuctionItem) error
        GetAll() ([]entity.AuctionItem, error)
        GetByID(id int64) (*entity.AuctionItem, error)
        ReadBySession(sessionID int64) ([]entity.AuctionItem, error)
        Update(item *entity.AuctionItem) error
        Delete(id int64) error
}

type auctionItemRepository struct {
        db *gorm.DB
}

func NewAuctionItemRepository(db *gorm.DB) AuctionItemRepository <span class="cov0" title="0">{
        return &amp;auctionItemRepository{db: db}
}</span>

func (r *auctionItemRepository) Create(item *entity.AuctionItem) error <span class="cov0" title="0">{
        return r.db.Create(item).Error
}</span>

func (r *auctionItemRepository) GetAll() ([]entity.AuctionItem, error) <span class="cov0" title="0">{
        var items []entity.AuctionItem
        err := r.db.Preload("Session").Preload("Photos").Find(&amp;items).Error
        return items, err
}</span>

func (r *auctionItemRepository) GetByID(id int64) (*entity.AuctionItem, error) <span class="cov0" title="0">{
        var item entity.AuctionItem
        err := r.db.Preload("Session").First(&amp;item, id).Error
        return &amp;item, err
}</span>

func (r *auctionItemRepository) ReadBySession(sessionID int64) ([]entity.AuctionItem, error) <span class="cov0" title="0">{
        var items []entity.AuctionItem
        err := r.db.Preload("Session").Preload("Photos").Where("session_id = ?", sessionID).Find(&amp;items).Error
        return items, err
}</span>

func (r *auctionItemRepository) Update(item *entity.AuctionItem) error <span class="cov0" title="0">{
        return r.db.Save(item).Error
}</span>

func (r *auctionItemRepository) Delete(id int64) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entity.AuctionItem{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "context"
        "milestone3/be/internal/entity"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"
)

type SessionRedisRepository interface {
        SetActiveSession(session entity.AuctionSession) error
        // GetActiveSessions() ([]entity.AuctionSession, error)
        DeleteSession(id int64) error
}

type sessionRedisRepository struct {
        client *redis.Client
        ctx    context.Context
}

func NewSessionRedisRepository(client *redis.Client, ctx context.Context) SessionRedisRepository <span class="cov0" title="0">{
        return &amp;sessionRedisRepository{client: client, ctx: ctx}
}</span>

func (r *sessionRedisRepository) SetActiveSession(session entity.AuctionSession) error <span class="cov0" title="0">{
        key := "active_session:" + strconv.FormatInt(session.ID, 10)

        if err := r.client.HSet(r.ctx, key, map[string]interface{}{
                "ID":        session.ID,
                "Name":      session.Name,
                "StartTime": session.StartTime.Unix(),
                "EndTime":   session.EndTime.Unix(),
        }).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">expiration := time.Until(session.EndTime)
        if expiration &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.client.Expire(r.ctx, key, expiration).Err()</span>
}

// func (r *sessionRedisRepository) GetActiveSessions() ([]entity.AuctionSession, error) {
//         var sessions []entity.AuctionSession

//         iter := r.client.Scan(r.ctx, 0, "active_session:*", 0).Iterator()
//         for iter.Next(r.ctx) {
//                 key := iter.Val()
//                 data, err := r.client.HGetAll(r.ctx, key).Result()
//                 if err != nil {
//                         return nil, err
//                 }

//                 id, _ := strconv.ParseInt(data["ID"], 10, 64)
//                 startTimeUnix, _ := strconv.ParseInt(data["StartTime"], 10, 64)
//                 endTimeUnix, _ := strconv.ParseInt(data["EndTime"], 10, 64)

//                 session := entity.AuctionSession{
//                         ID:        id,
//                         Name:      data["Name"],
//                         StartTime: time.Unix(startTimeUnix, 0),
//                         EndTime:   time.Unix(endTimeUnix, 0),
//                 }

//                 sessions = append(sessions, session)
//         }
//         if err := iter.Err(); err != nil {
//                 return nil, err
//         }

//         return sessions, nil
// }

func (r *sessionRedisRepository) DeleteSession(id int64) error <span class="cov0" title="0">{
        key := "active_session:" + strconv.FormatInt(id, 10)
        return r.client.Del(r.ctx, key).Err()
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package repository

import (
        "milestone3/be/internal/entity"
        "time"

        "gorm.io/gorm"
)

type AuctionSessionRepository interface {
        Create(session *entity.AuctionSession) error
        GetByID(id int64) (*entity.AuctionSession, error)
        GetAll() ([]*entity.AuctionSession, error)
        GetActiveSessions() ([]*entity.AuctionSession, error)
        Update(session *entity.AuctionSession) error
        Delete(id int64) error
}

type auctionSessionRepository struct {
        db *gorm.DB
}

func NewAuctionSessionRepository(db *gorm.DB) AuctionSessionRepository <span class="cov0" title="0">{
        return &amp;auctionSessionRepository{db: db}
}</span>

func (r *auctionSessionRepository) Create(session *entity.AuctionSession) error <span class="cov0" title="0">{
        return r.db.Create(session).Error
}</span>

func (r *auctionSessionRepository) GetByID(id int64) (*entity.AuctionSession, error) <span class="cov0" title="0">{
        var session entity.AuctionSession
        err := r.db.First(&amp;session, id).Error
        return &amp;session, err
}</span>

func (r *auctionSessionRepository) GetAll() ([]*entity.AuctionSession, error) <span class="cov0" title="0">{
        var sessions []*entity.AuctionSession
        err := r.db.Find(&amp;sessions).Error
        return sessions, err
}</span>

func (r *auctionSessionRepository) GetActiveSessions() ([]*entity.AuctionSession, error) <span class="cov0" title="0">{
        var sessions []*entity.AuctionSession
        now := time.Now()
        err := r.db.Where("start_time &lt;= ? AND end_time &gt;= ?", now, now).Find(&amp;sessions).Error
        return sessions, err
}</span>

func (r *auctionSessionRepository) Update(session *entity.AuctionSession) error <span class="cov0" title="0">{
        return r.db.Save(session).Error
}</span>

func (r *auctionSessionRepository) Delete(id int64) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entity.AuctionSession{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"
)

type BidRedisRepository interface {
        SetHighestBid(sessionID, itemID int64, amount float64, userID int64, sessionEndTime time.Time) error
        GetHighestBid(sessionID, itemID int64) (float64, int64, error)
        GetBidHistory(sessionID, itemID int64, limit int64) ([]BidEntry, error)
        GetSessionEndTime(sessionID int64) (time.Time, error)

        ScanKeys(pattern string) ([]string, error)
        GetBidByKey(key string) (BidEntry, error)
        DeleteKey(key string) error
}

type bidRedisRepository struct {
        client *redis.Client
        ctx    context.Context
}

type BidEntry struct {
        UserID int64
        ItemID int64
        Amount float64
}

func NewBidRedisRepository(client *redis.Client, ctx context.Context) BidRedisRepository <span class="cov0" title="0">{
        return &amp;bidRedisRepository{client: client, ctx: ctx}
}</span>

func (r *bidRedisRepository) SetHighestBid(sessionID, itemID int64, amount float64, userID int64, sessionEndTime time.Time) error <span class="cov0" title="0">{
        key := fmt.Sprintf("active:auction:%d:item:%d", sessionID, itemID)

        if err := r.client.HSet(r.ctx, key, map[string]interface{}{
                "highest_amount": amount,
                "highest_bidder": userID,
                "updated_at":     time.Now().Unix(),
                "end_time":       sessionEndTime.Unix(),
        }).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ttl := time.Until(sessionEndTime)
        if ttl &gt; 0 </span><span class="cov0" title="0">{
                if err := r.client.Expire(r.ctx, key, ttl).Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">historyKey := fmt.Sprintf("auction:%d:item:%d:history", sessionID, itemID)
        if err := r.client.ZAdd(r.ctx, historyKey, redis.Z{
                Score:  amount,
                Member: userID,
        }).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *bidRedisRepository) GetHighestBid(sessionID, itemID int64) (float64, int64, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("active:auction:%d:item:%d", sessionID, itemID)

        data, err := r.client.HGetAll(r.ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">amount, err := strconv.ParseFloat(data["highest_amount"], 64)
        if err != nil </span><span class="cov0" title="0">{
                amount = 0
        }</span>
        <span class="cov0" title="0">bidder, err := strconv.ParseInt(data["highest_bidder"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                bidder = 0
        }</span>

        <span class="cov0" title="0">return amount, bidder, nil</span>
}

func (r *bidRedisRepository) GetBidHistory(sessionID, itemID int64, limit int64) ([]BidEntry, error) <span class="cov0" title="0">{
        historyKey := fmt.Sprintf("auction:%d:item:%d:history", sessionID, itemID)

        results, err := r.client.ZRevRangeWithScores(r.ctx, historyKey, 0, limit-1).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var history []BidEntry
        for _, z := range results </span><span class="cov0" title="0">{
                userID, _ := strconv.ParseInt(fmt.Sprintf("%v", z.Member), 10, 64)
                history = append(history, BidEntry{
                        UserID: userID,
                        ItemID: itemID,
                        Amount: z.Score,
                })
        }</span>

        <span class="cov0" title="0">return history, nil</span>
}

func (r *bidRedisRepository) GetSessionEndTime(sessionID int64) (time.Time, error) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                key := "active_session:" + strconv.FormatInt(sessionID, 10)
                data, err := r.client.HGetAll(r.ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, err
                }</span>
                <span class="cov0" title="0">endTime, err := strconv.ParseInt(data["EndTime"], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, err
                }</span>
                <span class="cov0" title="0">return time.Unix(endTime, 0), nil</span>
        }
}

func (r *bidRedisRepository) ScanKeys(pattern string) ([]string, error) <span class="cov0" title="0">{
        var cursor uint64
        var keys []string
        for </span><span class="cov0" title="0">{
                var k []string
                var err error
                k, cursor, err = r.client.Scan(r.ctx, cursor, pattern, 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys = append(keys, k...)
                if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return keys, nil</span>
}

func (r *bidRedisRepository) GetBidByKey(key string) (BidEntry, error) <span class="cov0" title="0">{
        data, err := r.client.HGetAll(r.ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return BidEntry{}, err
        }</span>
        <span class="cov0" title="0">amount, _ := strconv.ParseFloat(data["highest_amount"], 64)
        userID, _ := strconv.ParseInt(data["highest_bidder"], 10, 64)
        itemID, _ := strconv.ParseInt(data["auction_item"], 10, 64)
        return BidEntry{
                UserID: userID,
                ItemID: itemID,
                Amount: amount,
        }, nil</span>
}

func (r *bidRedisRepository) DeleteKey(key string) error <span class="cov0" title="0">{
        return r.client.Del(r.ctx, key).Err()
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package repository

import (
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type BidRepository interface {
        SaveFinalBid(bid *entity.Bid) error
}

type bidRepository struct {
        db *gorm.DB
}

func NewBidRepository(db *gorm.DB) BidRepository <span class="cov0" title="0">{
        return &amp;bidRepository{db: db}
}</span>

func (r *bidRepository) SaveFinalBid(bid *entity.Bid) error <span class="cov0" title="0">{
        return r.db.Create(bid).Error
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package repository

import (
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type DonationRepo interface {
        CreateDonation(donation entity.Donation) error
        GetDonationByID(id uint) (entity.Donation, error)
        UpdateDonation(donation entity.Donation) error
        DeleteDonation(id uint) error

        // Admin-only or filtered queries
        GetAllDonations() ([]entity.Donation, error)
        GetDonationsByUserID(userID uint) ([]entity.Donation, error)

        PatchDonation(donation entity.Donation) error
}

type donationRepo struct {
        db *gorm.DB
}

func NewDonationRepo(db *gorm.DB) DonationRepo <span class="cov0" title="0">{
        return &amp;donationRepo{db: db}
}</span>

func (r *donationRepo) CreateDonation(donation entity.Donation) error <span class="cov0" title="0">{
        return r.db.Create(&amp;donation).Error
}</span>

func (r *donationRepo) GetAllDonations() ([]entity.Donation, error) <span class="cov0" title="0">{
        var donations []entity.Donation
        err := r.db.Find(&amp;donations).Error
        return donations, err
}</span>

func (r *donationRepo) GetDonationsByUserID(userID uint) ([]entity.Donation, error) <span class="cov0" title="0">{
        var donations []entity.Donation
        err := r.db.Where("user_id = ?", userID).Find(&amp;donations).Error
        return donations, err
}</span>

func (r *donationRepo) GetDonationByID(id uint) (entity.Donation, error) <span class="cov0" title="0">{
        var donation entity.Donation
        err := r.db.First(&amp;donation, id).Error
        return donation, err
}</span>

func (r *donationRepo) UpdateDonation(donation entity.Donation) error <span class="cov0" title="0">{
        return r.db.Save(&amp;donation).Error
}</span>

func (r *donationRepo) DeleteDonation(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entity.Donation{}, id).Error
}</span>

func (r *donationRepo) PatchDonation(donation entity.Donation) error <span class="cov0" title="0">{
        return r.db.Model(&amp;entity.Donation{}).Where("id = ?", donation.ID).Updates(donation).Error
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package repository

import (
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type FinalDonationRepository interface {
        GetAllFinalDonations() ([]entity.FinalDonation, error)
        GetAllFinalDonationsByUserID(userID int) ([]entity.FinalDonation, error)
}

type finalDonationRepository struct {
        db *gorm.DB
}

func NewFinalDonationRepository(db *gorm.DB) FinalDonationRepository <span class="cov0" title="0">{
        return &amp;finalDonationRepository{db: db}
}</span>

// Return final_donations where the related donation has status = entity.StatusVerifiedForDonation
func (r *finalDonationRepository) GetAllFinalDonations() ([]entity.FinalDonation, error) <span class="cov0" title="0">{
        var finalDonations []entity.FinalDonation
        err := r.db.
                Joins("JOIN donations d ON d.id = final_donations.donation_id").
                Where("d.status = ?", entity.StatusVerifiedForDonation).
                Preload("Donation").
                Find(&amp;finalDonations).Error
        return finalDonations, err
}</span>

// Return final_donations for a user by joining donations and filtering by donation.user_id
func (r *finalDonationRepository) GetAllFinalDonationsByUserID(userID int) ([]entity.FinalDonation, error) <span class="cov0" title="0">{
        var finalDonations []entity.FinalDonation
        err := r.db.
                Joins("JOIN donations d ON d.id = final_donations.donation_id").
                Where("d.user_id = ? AND d.status = ?", userID, entity.StatusVerifiedForDonation).
                Preload("Donation").
                Find(&amp;finalDonations).Error
        return finalDonations, err
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package repository

import (
        "context"
        "io"
        "log"
        "time"

        "cloud.google.com/go/storage"
)

type GCPStorageRepo interface {
        UploadFile(ctx context.Context, file io.Reader, objectName string) (string, error)
        GenerateSignedURL(ctx context.Context, objectName string, expire time.Duration) (string, error)
}

type gcpStorageRepo struct {
        client     *storage.Client
        bucketName string
        isPublic   bool
}

func NewGCPStorageRepo(client *storage.Client, bucketName string, isPublic bool) GCPStorageRepo <span class="cov0" title="0">{
        return &amp;gcpStorageRepo{
                client:     client,
                bucketName: bucketName,
                isPublic:   isPublic,
        }
}</span>

// UploadFile  handle file upload to GCS
func (r *gcpStorageRepo) UploadFile(ctx context.Context, file io.Reader, objectName string) (string, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 50*time.Second)
        defer cancel()

        obj := r.client.Bucket(r.bucketName).Object(objectName)
        writer := obj.NewWriter(ctx)

        // Copy file
        if _, err := io.Copy(writer, file); err != nil </span><span class="cov0" title="0">{
                log.Printf("GCS upload failed: %v", err)
                return "", err
        }</span>

        // Close writer
        <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("GCS writer close failed: %v", err)
                return "", err
        }</span>

        // PUBLIC bucket  return URL
        <span class="cov0" title="0">if r.isPublic </span><span class="cov0" title="0">{
                url := "https://storage.googleapis.com/" + r.bucketName + "/" + objectName
                log.Printf("Public file uploaded to: %s", url)
                return url, nil
        }</span>

        // PRIVATE bucket  return objectName
        <span class="cov0" title="0">log.Printf("Private file uploaded as object: %s", objectName)
        return objectName, nil</span>
}

// GenerateSignedURL  generate signed URL for private objects
func (r *gcpStorageRepo) GenerateSignedURL(ctx context.Context, objectName string, expire time.Duration) (string, error) <span class="cov0" title="0">{
        if r.isPublic </span><span class="cov0" title="0">{
                // Public bucket doesn't need signed URL
                url := "https://storage.googleapis.com/" + r.bucketName + "/" + objectName
                return url, nil
        }</span>

        // PRIVATE  generate signed URL
        <span class="cov0" title="0">url, err := storage.SignedURL(r.bucketName, objectName, &amp;storage.SignedURLOptions{
                Method:  "GET",
                Expires: time.Now().Add(expire),
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed generating signed URL: %v", err)
                return "", err
        }</span>

        <span class="cov0" title="0">return url, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "context"
        "milestone3/be/internal/dto"
        "milestone3/be/internal/entity"
        "os"

        "github.com/midtrans/midtrans-go"
        "github.com/midtrans/midtrans-go/coreapi"
        "gorm.io/gorm"
)

type PaymentRepo struct {
        db *gorm.DB
        ctx context.Context
}

func NewPaymentRepository(db *gorm.DB, ctx context.Context) *PaymentRepo <span class="cov0" title="0">{
        return &amp;PaymentRepo{db: db, ctx: ctx}
}</span>

func (pr *PaymentRepo) Create(payment *entity.Payment, orderId string) (error) <span class="cov0" title="0">{
        payment.OrderId = orderId
        if err := pr.db.WithContext(pr.ctx).Omit("Status").Preload("User").Create(payment).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pr *PaymentRepo) GetById(id int) (payment entity.Payment, err error) <span class="cov0" title="0">{
        if err := pr.db.WithContext(pr.ctx).Preload("User").First(&amp;payment, id).Error; err != nil </span><span class="cov0" title="0">{
                return entity.Payment{}, err
        }</span>

        <span class="cov0" title="0">return payment, nil</span>
}

func (pr *PaymentRepo) GetAll() (payment []entity.Payment, err error) <span class="cov0" title="0">{
        if err := pr.db.WithContext(pr.ctx).Preload("User").Find(&amp;payment).Error; err != nil </span><span class="cov0" title="0">{
                return []entity.Payment{}, err
        }</span>

        <span class="cov0" title="0">return payment, err</span>
}

func (pr *PaymentRepo) CreateMidtrans(payment entity.Payment, orderId string) (res dto.PaymentResponse, err error) <span class="cov0" title="0">{
        serverKey := os.Getenv("MIDTRANS_SERVER_KEY")
        c := coreapi.Client{}
        c.New(serverKey, midtrans.Sandbox)
        chargeReq := &amp;coreapi.ChargeReq{
                PaymentType: coreapi.PaymentTypeQris,
                TransactionDetails: midtrans.TransactionDetails{
                        OrderID: orderId,
                        GrossAmt: int64(payment.Amount),
                },
                CustomerDetails: &amp;midtrans.CustomerDetails{
                        FName: payment.User.Name,
                        Email: payment.User.Email,
                },
        }
        coreApiResp, _ := c.ChargeTransaction(chargeReq)

        var paymentURL string
    if len(coreApiResp.Actions) &gt; 0 </span><span class="cov0" title="0">{
        paymentURL = coreApiResp.Actions[1].URL
    }</span>

        <span class="cov0" title="0">resp := dto.PaymentResponse{
                PaymentLinkUrl: paymentURL,
                TransactionId: coreApiResp.TransactionID,
                ExpiryTime: coreApiResp.ExpiryTime,
                OrderId: coreApiResp.OrderID,
        }
        return resp, nil</span>
}

func (pr *PaymentRepo) CheckPaymentStatusMidtrans(orderId string) (res dto.CheckPaymentStatusResponse, err error) <span class="cov0" title="0">{
        var payment entity.Payment
        serverKey := os.Getenv("MIDTRANS_SERVER_KEY")
        c := coreapi.Client{}
        c.New(serverKey, midtrans.Sandbox)        

        resp, err := c.CheckTransaction(orderId)
        if err != nil </span><span class="cov0" title="0">{
                return dto.CheckPaymentStatusResponse{}, err
        }</span>

        <span class="cov0" title="0">respon := dto.CheckPaymentStatusResponse{
                OrderId: resp.OrderID,
                TransactionId: resp.TransactionID,
                PaymentStatus: resp.TransactionStatus,
        }
        switch resp.TransactionStatus </span>{
        case "settlement":<span class="cov0" title="0">
                pr.db.Model(&amp;payment).WithContext(pr.ctx).Where("order_id = ?", orderId).Update("status", "paid")</span>
        case "cancel", "expire":<span class="cov0" title="0">
                pr.db.Model(&amp;payment).WithContext(pr.ctx).Where("order_id = ?", orderId).Update("status", "failed")</span>
        }
        
        <span class="cov0" title="0">return respon, nil</span>
}</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "context"
        "milestone3/be/internal/entity"

        "gorm.io/gorm"
)

type UserRepo struct {
        ctx context.Context
        db *gorm.DB
}

func NewUserRepo(db *gorm.DB, ctx context.Context) *UserRepo <span class="cov0" title="0">{
        return &amp;UserRepo{db: db, ctx: ctx}
}</span>

func (ur *UserRepo) Create(user *entity.Users) error <span class="cov0" title="0">{
        if err := ur.db.WithContext(ur.ctx).Omit("Role").Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (ur *UserRepo) GetByEmail(email string) (user entity.Users, err error) <span class="cov0" title="0">{
        if err := ur.db.WithContext(ur.ctx).First(&amp;user, "email = ?", email).Error; err != nil </span><span class="cov0" title="0">{
                return entity.Users{}, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
func (ur *UserRepo) GetById(id int) (user entity.Users, err error) <span class="cov0" title="0">{
        if err := ur.db.WithContext(ur.ctx).First(&amp;user, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return entity.Users{}, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
// reset password?
// validation?</pre>
		
		<pre class="file" id="file47" style="display: none">package service

import (
        "log"
        "milestone3/be/internal/dto"
)

type AdminRepository interface {
        CountPayment() (count int64, err error)
        CountDonation() (count int64, err error)
        CountArticle() (count int64, err error)
        CountAuction() (count int64, err error)
}

type AdminServ struct {
        adminRepo AdminRepository
}

func NewAdminService(ar AdminRepository) *AdminServ <span class="cov0" title="0">{
        return &amp;AdminServ{adminRepo: ar}
}</span>

func (as *AdminServ) AdminDashboard() (resp dto.AdminDashboardResponse, err error) <span class="cov0" title="0">{
        log.Println("article")
        article, err := as.adminRepo.CountArticle()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error count article %s", err)
                return dto.AdminDashboardResponse{}, err
        }</span>

        <span class="cov0" title="0">log.Println("donation")
        donation, err := as.adminRepo.CountDonation() 
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error count donation %s", err)
                return dto.AdminDashboardResponse{}, err
        }</span>

        <span class="cov0" title="0">log.Println("payment")
        payment, err := as.adminRepo.CountPayment()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error count payment %s", err)
                return dto.AdminDashboardResponse{}, err
        }</span>

        <span class="cov0" title="0">auction, err := as.adminRepo.CountAuction(); 
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error count payment %s", err)
                return dto.AdminDashboardResponse{}, err
        }</span>

        <span class="cov0" title="0">respon := dto.AdminDashboardResponse{
                TotalArticle: article,
                TotalDonation: donation,
                TotalPayment: payment,
                TotalAuction: auction,
        }

        return respon, nil</span>
}

// work in progress (WIP)
// func (as *AdminServ) AdminReport() (err error) { }</pre>
		
		<pre class="file" id="file48" style="display: none">package service

import (
        "errors"

        "milestone3/be/internal/dto"
        "milestone3/be/internal/repository"

        "gorm.io/gorm"
)

type ArticleService interface {
        CreateArticle(articleDTO dto.ArticleDTO) error
        GetAllArticles() ([]dto.ArticleDTO, error)
        GetArticleByID(id uint) (dto.ArticleDTO, error)
        UpdateArticle(articleDTO dto.ArticleDTO) error
        DeleteArticle(id uint) error
}

type articleService struct {
        repo repository.ArticleRepo
}

func NewArticleService(repo repository.ArticleRepo) ArticleService <span class="cov0" title="0">{
        return &amp;articleService{repo: repo}
}</span>

func (s *articleService) CreateArticle(articleDTO dto.ArticleDTO) error <span class="cov0" title="0">{
        article, err := dto.ArticleRequest(articleDTO)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.repo.CreateArticle(article)</span>
}

func (s *articleService) GetAllArticles() ([]dto.ArticleDTO, error) <span class="cov0" title="0">{
        articles, err := s.repo.GetAllArticles()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dto.ArticleResponses(articles), nil</span>
}

func (s *articleService) GetArticleByID(id uint) (dto.ArticleDTO, error) <span class="cov0" title="0">{
        article, err := s.repo.GetArticleByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return dto.ArticleDTO{}, ErrArticleNotFound
                }</span>
                <span class="cov0" title="0">return dto.ArticleDTO{}, err</span>
        }
        <span class="cov0" title="0">return dto.ArticleResponse(article), nil</span>
}

func (s *articleService) UpdateArticle(articleDTO dto.ArticleDTO) error <span class="cov0" title="0">{
        article, err := dto.ArticleRequest(articleDTO)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.repo.UpdateArticle(article); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrArticleNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *articleService) DeleteArticle(id uint) error <span class="cov0" title="0">{
        if err := s.repo.DeleteArticle(id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrArticleNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package service

import (
        "log/slog"
        "milestone3/be/internal/dto"
        "milestone3/be/internal/repository"
)

type itemsService struct {
        repo   repository.AuctionItemRepository
        logger *slog.Logger
        ai     repository.AIRepository
}

type AuctionItemService interface {
        Create(item *dto.AuctionItemDTO) (dto.AuctionItemDTO, error)
        GetAll() ([]dto.AuctionItemDTO, error)
        GetByID(id int64) (dto.AuctionItemDTO, error)
        Update(id int64, item *dto.AuctionItemDTO) (dto.AuctionItemDTO, error)
        Delete(id int64) error
}

func NewAuctionItemService(r repository.AuctionItemRepository, aiRepo repository.AIRepository, logger *slog.Logger) AuctionItemService <span class="cov0" title="0">{
        return &amp;itemsService{repo: r, logger: logger, ai: aiRepo}
}</span>

func (s *itemsService) Create(itemDTO *dto.AuctionItemDTO) (dto.AuctionItemDTO, error) <span class="cov0" title="0">{
        item, err := dto.AuctionItemRequest(*itemDTO)
        if err != nil </span><span class="cov0" title="0">{
                return dto.AuctionItemDTO{}, ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">estimationReq := repository.PriceEstimationRequest{
                Name:        itemDTO.Title,
                Category:    itemDTO.Category,
                Description: itemDTO.Description,
        }

        estimatedPrice, err := s.ai.EstimateStartingPrice(estimationReq)
        if err != nil </span><span class="cov0" title="0">{
                // AI estimation failed  log and fallback to provided starting price or sensible default
                s.logger.Warn("EstimateStartingPrice failed, falling back to provided/default price", "error", err)
                // prefer client-provided StartingPrice if present
                if itemDTO.StartingPrice &gt; 0 </span><span class="cov0" title="0">{
                        estimatedPrice = itemDTO.StartingPrice
                }</span> else<span class="cov0" title="0"> {
                        // sensible default to avoid blocking creation
                        estimatedPrice = 100
                }</span>
        }

        <span class="cov0" title="0">item.StartingPrice = estimatedPrice

        if item.Status == "" </span><span class="cov0" title="0">{
                item.Status = "scheduled"
        }</span>

        <span class="cov0" title="0">err = s.repo.Create(&amp;item)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create auction item", "error", err)
                return dto.AuctionItemDTO{}, ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">return dto.AuctionItemResponse(item), nil</span>
}

func (s *itemsService) GetAll() ([]dto.AuctionItemDTO, error) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                items, err := s.repo.GetAll()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get all auction items", "error", err)
                        return nil, ErrAuctionNotFound
                }</span>

                <span class="cov0" title="0">var itemDTOs []dto.AuctionItemDTO
                for _, item := range items </span><span class="cov0" title="0">{
                        itemDTOs = append(itemDTOs, dto.AuctionItemResponse(item))
                }</span>

                <span class="cov0" title="0">return itemDTOs, nil</span>
        }
}

func (s *itemsService) GetByID(id int64) (dto.AuctionItemDTO, error) <span class="cov0" title="0">{
        item, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return dto.AuctionItemDTO{}, ErrAuctionNotFoundID
        }</span>
        <span class="cov0" title="0">return dto.AuctionItemResponse(*item), nil</span>
}

func (s *itemsService) Update(id int64, itemDTO *dto.AuctionItemDTO) (dto.AuctionItemDTO, error) <span class="cov0" title="0">{
        existingItem, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get auction item by ID for update", "error", err)
                return dto.AuctionItemDTO{}, ErrAuctionNotFoundID
        }</span>

        <span class="cov0" title="0">updatedItem, err := dto.AuctionItemRequest(*itemDTO)
        if err != nil </span><span class="cov0" title="0">{
                return dto.AuctionItemDTO{}, ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">updatedItem.ID = existingItem.ID
        updatedItem.CreatedAt = existingItem.CreatedAt

        err = s.repo.Update(&amp;updatedItem)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update auction item", "error", err)
                return dto.AuctionItemDTO{}, ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">return dto.AuctionItemResponse(updatedItem), nil</span>
}

func (s *itemsService) Delete(id int64) error <span class="cov0" title="0">{
        _, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return ErrAuctionNotFoundID
        }</span>

        <span class="cov0" title="0">err = s.repo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete auction item", "error", err)
                return ErrInvalidAuction
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package service

import (
        "log/slog"
        "milestone3/be/internal/dto"
        "milestone3/be/internal/entity"
        "milestone3/be/internal/repository"
        "time"
)

type sessionService struct {
        repo      repository.AuctionSessionRepository
        redisRepo repository.SessionRedisRepository
        logger    *slog.Logger
}

type AuctionSessionService interface {
        Create(session *dto.AuctionSessionDTO) (dto.AuctionSessionDTO, error)
        GetByID(id int64) (dto.AuctionSessionDTO, error)
        GetAll() ([]dto.AuctionSessionDTO, error)
        Update(id int64, session *dto.AuctionSessionDTO) (dto.AuctionSessionDTO, error)
        Delete(id int64) error
}

func NewAuctionSessionService(r repository.AuctionSessionRepository, rr repository.SessionRedisRepository, logger *slog.Logger) AuctionSessionService <span class="cov0" title="0">{
        return &amp;sessionService{repo: r, redisRepo: rr, logger: logger}
}</span>

func (s *sessionService) Create(d *dto.AuctionSessionDTO) (dto.AuctionSessionDTO, error) <span class="cov0" title="0">{
        if d.Name == "" || d.EndTime.Before(d.StartTime) </span><span class="cov0" title="0">{
                return dto.AuctionSessionDTO{}, ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">session := entity.AuctionSession{
                Name:      d.Name,
                StartTime: d.StartTime,
                EndTime:   d.EndTime,
        }

        err := s.repo.Create(&amp;session)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create auction session", "error", err)
                return dto.AuctionSessionDTO{}, ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if session.StartTime.Before(now) &amp;&amp; session.EndTime.After(now) </span><span class="cov0" title="0">{
                if err := s.redisRepo.SetActiveSession(session); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to cache active session in Redis", "error", err)
                }</span>
        }

        <span class="cov0" title="0">return dto.AuctionSessionResponse(session), nil</span>
}

func (s *sessionService) GetByID(id int64) (dto.AuctionSessionDTO, error) <span class="cov0" title="0">{
        session, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get auction session by ID", "error", err)
                return dto.AuctionSessionDTO{}, ErrSessionNotFoundID
        }</span>

        <span class="cov0" title="0">return dto.AuctionSessionResponse(*session), nil</span>
}

func (s *sessionService) GetAll() ([]dto.AuctionSessionDTO, error) <span class="cov0" title="0">{
        sessions, err := s.repo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get all auction sessions", "error", err)
                return nil, ErrSessionNotFoundID
        }</span>

        <span class="cov0" title="0">var sessionDTOs []dto.AuctionSessionDTO
        for _, session := range sessions </span><span class="cov0" title="0">{
                sessionDTOs = append(sessionDTOs, dto.AuctionSessionResponse(*session))
        }</span>

        <span class="cov0" title="0">return sessionDTOs, nil</span>
}

func (s *sessionService) Update(id int64, d *dto.AuctionSessionDTO) (dto.AuctionSessionDTO, error) <span class="cov0" title="0">{
        session, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get auction session by ID for update", "error", err)
                return dto.AuctionSessionDTO{}, ErrSessionNotFoundID
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if session.StartTime.Before(now) &amp;&amp; session.EndTime.After(now) </span><span class="cov0" title="0">{
                return dto.AuctionSessionDTO{}, ErrActiveSession
        }</span>
        <span class="cov0" title="0">if session.EndTime.Before(now) </span><span class="cov0" title="0">{
                return dto.AuctionSessionDTO{}, ErrInvalidDate
        }</span>

        <span class="cov0" title="0">if d.Name != "" </span><span class="cov0" title="0">{
                session.Name = d.Name
        }</span>
        <span class="cov0" title="0">if !d.StartTime.IsZero() </span><span class="cov0" title="0">{
                session.StartTime = d.StartTime
        }</span>
        <span class="cov0" title="0">if !d.EndTime.IsZero() </span><span class="cov0" title="0">{
                session.EndTime = d.EndTime
        }</span>

        <span class="cov0" title="0">if session.EndTime.Before(session.StartTime) </span><span class="cov0" title="0">{
                return dto.AuctionSessionDTO{}, ErrInvalidDate
        }</span>

        // assign to DB
        <span class="cov0" title="0">err = s.repo.Update(session)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update auction session", "error", err)
                return dto.AuctionSessionDTO{}, ErrInvalidAuction
        }</span>

        // update Redis if session is active
        <span class="cov0" title="0">if session.StartTime.Before(now) &amp;&amp; session.EndTime.After(now) </span><span class="cov0" title="0">{
                if err := s.redisRepo.SetActiveSession(*session); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to update active session in Redis", "error", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := s.redisRepo.DeleteSession(session.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to delete session from Redis", "error", err)
                }</span>
        }

        <span class="cov0" title="0">return dto.AuctionSessionResponse(*session), nil</span>
}

func (s *sessionService) Delete(id int64) error <span class="cov0" title="0">{
        session, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get auction session by ID for delete", "error", err)
                return ErrSessionNotFoundID
        }</span>

        <span class="cov0" title="0">now := time.Now()

        if session.StartTime.Before(now) &amp;&amp; session.EndTime.After(now) </span><span class="cov0" title="0">{
                return ErrActiveSession
        }</span>

        <span class="cov0" title="0">if session.EndTime.Before(now) </span><span class="cov0" title="0">{
                return ErrInvalidDate
        }</span>

        <span class="cov0" title="0">err = s.repo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete auction session", "error", err)
                return ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">if err := s.redisRepo.DeleteSession(session.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete session from Redis", "error", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package service

import (
        "errors"
        "log/slog"
        "milestone3/be/internal/entity"
        "milestone3/be/internal/repository"
        "strconv"
        "strings"
        "time"

        "github.com/redis/go-redis/v9"
)

type bidService struct {
        redisRepo repository.BidRedisRepository
        bidRepo   repository.BidRepository
        itemRepo  repository.AuctionItemRepository
        logger    *slog.Logger
}

type BidService interface {
        PlaceBid(sessionID, itemID, userID int64, amount float64, sessionEndTime time.Time) error
        GetHighestBid(sessionID, itemID int64) (float64, int64, error)
        SyncHighestBid(sessionID, itemID int64) error

        SaveExpiredSessions(sessionID int64) error
}

func NewBidService(r repository.BidRedisRepository, b repository.BidRepository, itemRepo repository.AuctionItemRepository, logger *slog.Logger) BidService <span class="cov0" title="0">{
        return &amp;bidService{redisRepo: r, bidRepo: b, itemRepo: itemRepo, logger: logger}
}</span>

func (s *bidService) PlaceBid(sessionID, itemID, userID int64, amount float64, sessionEndTime time.Time) error <span class="cov0" title="0">{
        if amount &lt;= 0 </span><span class="cov0" title="0">{
                return ErrInvalidBidding
        }</span>

        <span class="cov0" title="0">item, err := s.itemRepo.GetByID(itemID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("item not found", "itemID", itemID, "error", err)
                return ErrAuctionNotFound
        }</span>

        <span class="cov0" title="0">s.logger.Info("item found", "itemID", itemID, "status", item.Status, "sessionID", item.SessionID)

        if item.Status != "ongoing" </span><span class="cov0" title="0">{
                s.logger.Warn("item not ongoing", "itemID", itemID, "status", item.Status)
                return ErrInvalidAuction
        }</span>

        <span class="cov0" title="0">highest, bidder, err := s.redisRepo.GetHighestBid(sessionID, itemID)
        if err != nil &amp;&amp; !errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                s.logger.Error("failed to get highest bid", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">if amount &lt;= highest </span><span class="cov0" title="0">{
                return ErrBidTooLow
        }</span>

        <span class="cov0" title="0">err = s.redisRepo.SetHighestBid(sessionID, itemID, amount, userID, sessionEndTime)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to set highest bid", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("new highest bid",
                "itemID", itemID,
                "userID", userID,
                "oldBid", highest,
                "oldBidder", bidder,
                "newBid", amount,
        )

        return nil</span>
}

func (s *bidService) GetHighestBid(sessionID, itemID int64) (float64, int64, error) <span class="cov0" title="0">{
        _, err := s.itemRepo.GetByID(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, ErrAuctionNotFound
        }</span>
        <span class="cov0" title="0">return s.redisRepo.GetHighestBid(sessionID, itemID)</span>
}

func (s *bidService) SyncHighestBid(sessionID, itemID int64) error <span class="cov0" title="0">{
        highest, bidder, err := s.redisRepo.GetHighestBid(sessionID, itemID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get highest bid", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">if highest == 0 || bidder == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">finalBid := &amp;entity.Bid{
                SessionID: sessionID,
                ItemID:    itemID,
                Amount:    highest,
                UserID:    bidder,
        }

        err = s.bidRepo.SaveFinalBid(finalBid)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to save final bid to postgres", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("highest bid synced to postgres",
                "sessionID", sessionID,
                "itemID", itemID,
                "bid", highest,
                "bidder", bidder,
        )

        return nil</span>
}

func parseKey(key string) (sessionID, itemID int64, err error) <span class="cov0" title="0">{
        parts := strings.Split(key, ":")
        // format: auction_session:{sessionID}:item:{itemID}
        sID, err := strconv.ParseInt(parts[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">iID, err := strconv.ParseInt(parts[3], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">return sID, iID, nil</span>
}

func (s *bidService) SaveExpiredSessions(sessionID int64) error <span class="cov0" title="0">{
        keys, err := s.redisRepo.ScanKeys("auction_session:*:item:*")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                // get key: auction_session:10:item:5
                sessionID, itemID, err := parseKey(key)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // result from bid redis
                <span class="cov0" title="0">bid, err := s.redisRepo.GetBidByKey(key)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // get end time
                <span class="cov0" title="0">endTime, err := s.redisRepo.GetSessionEndTime(sessionID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if time.Now().Before(endTime) </span><span class="cov0" title="0">{
                        continue</span> // belum expired
                }

                // assign to DB
                <span class="cov0" title="0">err = s.bidRepo.SaveFinalBid(&amp;entity.Bid{
                        SessionID: sessionID,
                        ItemID:    itemID,
                        UserID:    bid.UserID,
                        Amount:    bid.Amount,
                })
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">_ = s.redisRepo.DeleteKey(key)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package service

import (
        "context"
        "errors"
        "io"
        "time"

        "milestone3/be/internal/dto"
        "milestone3/be/internal/repository"

        "gorm.io/gorm"
)

type DonationService interface {
        CreateDonation(donationDTO dto.DonationDTO) error
        GetAllDonations(userID uint, isAdmin bool) ([]dto.DonationDTO, error)
        GetDonationByID(id uint) (dto.DonationDTO, error)
        UpdateDonation(donationDTO dto.DonationDTO, userID uint, isAdmin bool) error
        DeleteDonation(id uint, userID uint, isAdmin bool) error
        PatchDonation(donationDTO dto.DonationDTO, userID uint, isAdmin bool) error
        CanManageDonations(userID uint, ownerID uint, isAdmin bool) bool
}

type donationService struct {
        repo         repository.DonationRepo
        privateStore repository.GCPStorageRepo
}

func NewDonationService(repo repository.DonationRepo, privateStore repository.GCPStorageRepo) DonationService <span class="cov0" title="0">{
        return &amp;donationService{
                repo:         repo,
                privateStore: privateStore,
        }
}</span>

func (s *donationService) CreateDonation(donationDTO dto.DonationDTO) error <span class="cov0" title="0">{
        donation, err := dto.DonationRequest(donationDTO)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.repo.CreateDonation(donation)</span>
}

func (s *donationService) GetAllDonations(userID uint, isAdmin bool) ([]dto.DonationDTO, error) <span class="cov0" title="0">{
        if isAdmin </span><span class="cov0" title="0">{
                donations, err := s.repo.GetAllDonations()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return dto.DonationResponses(donations), nil</span>
        }
        <span class="cov0" title="0">donations, err := s.repo.GetDonationsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dto.DonationResponses(donations), nil</span>
}

func (s *donationService) GetDonationByID(id uint) (dto.DonationDTO, error) <span class="cov0" title="0">{
        donation, err := s.repo.GetDonationByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return dto.DonationDTO{}, ErrDonationNotFound
                }</span>
                <span class="cov0" title="0">return dto.DonationDTO{}, err</span>
        }
        <span class="cov0" title="0">return dto.DonationResponse(donation), nil</span>
}

func (s *donationService) UpdateDonation(donationDTO dto.DonationDTO, userID uint, isAdmin bool) error <span class="cov0" title="0">{
        donation, err := dto.DonationRequest(donationDTO)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">existing, err := s.repo.GetDonationByID(donation.ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrDonationNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if !s.CanManageDonations(userID, existing.UserID, isAdmin) </span><span class="cov0" title="0">{
                return ErrForbidden
        }</span>

        <span class="cov0" title="0">return s.repo.UpdateDonation(donation)</span>
}

func (s *donationService) DeleteDonation(id uint, userID uint, isAdmin bool) error <span class="cov0" title="0">{
        donation, err := s.repo.GetDonationByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrDonationNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if !s.CanManageDonations(userID, donation.UserID, isAdmin) </span><span class="cov0" title="0">{
                return ErrForbidden
        }</span>

        <span class="cov0" title="0">return s.repo.DeleteDonation(id)</span>
}

func (s *donationService) PatchDonation(donationDTO dto.DonationDTO, userID uint, isAdmin bool) error <span class="cov0" title="0">{
        donation, err := dto.DonationRequest(donationDTO)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">existing, err := s.repo.GetDonationByID(donation.ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrDonationNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if !s.CanManageDonations(userID, existing.UserID, isAdmin) </span><span class="cov0" title="0">{
                return ErrForbidden
        }</span>

        <span class="cov0" title="0">return s.repo.PatchDonation(donation)</span>
}

func (s *donationService) CanManageDonations(userID uint, ownerID uint, isAdmin bool) bool <span class="cov0" title="0">{
        if isAdmin </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return userID == ownerID</span>
}

// ======================
//  METHODS FOR GCS
// ======================

func (s *donationService) UploadDonationImage(ctx context.Context, file io.Reader, fileName string) (string, error) <span class="cov0" title="0">{
        objectName, err := s.privateStore.UploadFile(ctx, file, fileName)
        if err != nil </span><span class="cov0" title="0">{
                return ErrImageNotFound.Error(), err
        }</span>
        <span class="cov0" title="0">return objectName, nil</span>
}

func (s *donationService) GetDonationImageURL(ctx context.Context, objectName string) (string, error) <span class="cov0" title="0">{
        url, err := s.privateStore.GenerateSignedURL(ctx, objectName, 10*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                return ErrSignedURLFailed.Error(), err
        }</span>
        <span class="cov0" title="0">return url, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package service

import (
        "milestone3/be/internal/entity"
        "milestone3/be/internal/repository"
)

type FinalDonationService interface {
        GetAllFinalDonations() ([]entity.FinalDonation, error)
        GetAllFinalDonationsByUserID(userID int) ([]entity.FinalDonation, error)
}

type finalDonationService struct {
        finalDonationRepo repository.FinalDonationRepository
}

func NewFinalDonationService(finalDonationRepo repository.FinalDonationRepository) FinalDonationService <span class="cov0" title="0">{
        return &amp;finalDonationService{finalDonationRepo: finalDonationRepo}
}</span>

func (s *finalDonationService) GetAllFinalDonations() ([]entity.FinalDonation, error) <span class="cov0" title="0">{
        return s.finalDonationRepo.GetAllFinalDonations()
}</span>

func (s *finalDonationService) GetAllFinalDonationsByUserID(userID int) ([]entity.FinalDonation, error) <span class="cov0" title="0">{
        return s.finalDonationRepo.GetAllFinalDonationsByUserID(userID)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package service

import (
        "fmt"
        "log"
        "milestone3/be/internal/dto"
        "milestone3/be/internal/entity"

        "github.com/google/uuid"
)

type PaymentRepository interface {
        Create(payment *entity.Payment, orderId string) (error)
        CreateMidtrans(payment entity.Payment, orderId string) (res dto.PaymentResponse, err error)
        CheckPaymentStatusMidtrans(orderId string) (res dto.CheckPaymentStatusResponse, err error)
        GetById(id int) (payment entity.Payment, err error)
        GetAll() (payment []entity.Payment, err error)
}

type PaymentServ struct {
        paymentRepo PaymentRepository
}

func NewPaymentService(pr PaymentRepository) *PaymentServ <span class="cov8" title="1">{
        return &amp;PaymentServ{paymentRepo: pr}
}</span>

func (ps *PaymentServ) CreatePayment(req dto.PaymentRequest, userId int, auctionItemId int) (res dto.PaymentResponse, err error) <span class="cov8" title="1">{
        //random id for order id
        uuid := uuid.New()
        orderId := fmt.Sprintf("YDR-%d", uuid.ID())
        
        payment := entity.Payment{
                Amount: req.Amount,
                UserId: userId,
                //hard code for now 
                AuctionItemId: auctionItemId,
        }

        
        log.Println("disini nih")
        resp, _ := ps.paymentRepo.CreateMidtrans(payment, orderId)
        
        if err := ps.paymentRepo.Create(&amp;payment, resp.OrderId); err != nil </span><span class="cov8" title="1">{
                log.Printf("error create payment %s", err)
                return dto.PaymentResponse{}, err
        }</span>
        <span class="cov8" title="1">return resp, nil</span>
}

func (ps *PaymentServ) CheckPaymentStatusMidtrans(orderId string) (res dto.CheckPaymentStatusResponse, err error) <span class="cov0" title="0">{
        resp, _:= ps.paymentRepo.CheckPaymentStatusMidtrans(orderId)

        return resp, nil
}</span>

func (ps *PaymentServ) GetPaymentById(id int) (res dto.PaymentInfoResponse, err error) <span class="cov8" title="1">{
        resp, err := ps.paymentRepo.GetById(id)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("failed get payment by id %s", err)
                return dto.PaymentInfoResponse{}, err
        }</span>

        <span class="cov8" title="1">res = dto.PaymentInfoResponse{
                Id: resp.Id,
                UserId: resp.UserId,
                User: resp.User,
                AuctionItemId: resp.AuctionItemId,
                Status: resp.Status,
                // PaymentStatus: resp.PaymentStatus,
                Amount: resp.Amount,
        }

        return res, nil</span>
}

func (ps *PaymentServ) GetAllPayment() (res []dto.PaymentInfoResponse, err error) <span class="cov0" title="0">{
        resp, err := ps.paymentRepo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed get all payment info %s", err)
                return []dto.PaymentInfoResponse{}, err
        }</span>

        <span class="cov0" title="0">for _, payment := range resp </span><span class="cov0" title="0">{
                res = append(res, dto.PaymentInfoResponse{
                Id: payment.Id,
                UserId: payment.UserId,
                User: payment.User,
                AuctionItemId: payment.AuctionItemId,
                Status: payment.Status,
                // PaymentStatus: payment.PaymentStatus,
                Amount: payment.Amount,
                })
        }</span>

        <span class="cov0" title="0">return res, nil</span>
}</pre>
		
		<pre class="file" id="file55" style="display: none">package service

import (
        "log"
        "milestone3/be/internal/dto"
        "milestone3/be/internal/entity"
        "milestone3/be/internal/utils"

        "golang.org/x/crypto/bcrypt"
)

type UserRepository interface {
        Create(user *entity.Users) error
        GetByEmail(email string) (user entity.Users, err error)
        GetById(id int) (user entity.Users, err error)
}

type UserServ struct {
        userRepo UserRepository
}

func NewUserService(ur UserRepository) *UserServ <span class="cov8" title="1">{
        return &amp;UserServ{userRepo: ur}
}</span>

func (us *UserServ) CreateUser(req dto.UserRequest) (res dto.UserResponse, err error) <span class="cov8" title="1">{
        passHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error encrypt password")
                return dto.UserResponse{}, err
        }</span>

        <span class="cov8" title="1">req.Password = string(passHash)

        user := entity.Users{
                Name: req.Name,
                Email: req.Email,
                Password: req.Password,
        }

        if err := us.userRepo.Create(&amp;user); err != nil </span><span class="cov0" title="0">{
                return dto.UserResponse{}, err
        }</span>

        //get user id to show in the response
        <span class="cov8" title="1">userInfo, err := us.GetUserById(user.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("failed get user by id")
                return dto.UserResponse{}, err
        }</span>

        <span class="cov8" title="1">return userInfo, nil</span>
}

func (us *UserServ) GetUserById(id int) (res dto.UserResponse, err error) <span class="cov8" title="1">{
        user, err := us.userRepo.GetById(id)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("failed get user by id")
                return dto.UserResponse{}, err
        }</span>

        <span class="cov8" title="1">userInfo := dto.UserResponse{
                Id: user.Id,
                Name: user.Name,
                Email: user.Email,
                Role: user.Role,
        }

        return userInfo, nil</span>
}

func (us *UserServ) GetUserByEmail(email, password string) (accessToken string, err error) <span class="cov0" title="0">{
        user, err := us.userRepo.GetByEmail(email) 
        if err != nil </span><span class="cov0" title="0">{
                log.Println("failed get user by email", err.Error())
                return "", err
        }</span>                

        // WIP auth/validation
        //validation??
        //mailjet validation kalo ada 

        //compare hash pass and input pass
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil </span><span class="cov0" title="0">{
                log.Println("failed to compare password hash")
                return "", err
        }</span>

        <span class="cov0" title="0">token, err := utils.GenerateJwtToken(email, user.Role, user.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("failed to generate jwt token")
                return "", err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}</pre>
		
		<pre class="file" id="file56" style="display: none">package utils

import "github.com/labstack/echo/v4"

// GetUserID reads user id from context (set by auth middleware).
// Returns (0,false) when not present/invalid.
func GetUserID(c echo.Context) (uint, bool) <span class="cov0" title="0">{
        v := c.Get("user_id")
        switch t := v.(type) </span>{
        case uint:<span class="cov0" title="0">
                return t, true</span>
        case int:<span class="cov0" title="0">
                return uint(t), true</span>
        case int64:<span class="cov0" title="0">
                return uint(t), true</span>
        case float64:<span class="cov0" title="0">
                return uint(t), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// IsAdmin reads "is_admin" flag from context (set by auth middleware).
func IsAdmin(c echo.Context) bool <span class="cov0" title="0">{
        v := c.Get("is_admin")
        if b, ok := v.(bool); ok &amp;&amp; b </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package utils

import (
        "log"
        "os"
        "strconv"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// for generate and validate jwt token
func GenerateJwtToken(email, role string, id int) (string, error) <span class="cov0" title="0">{
        expired_jwt := os.Getenv("EXPIRED_JWT")
        expired_jwt_int, err := strconv.Atoi(expired_jwt)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error parsing expired_jwt to int")
                return "", err
        }</span>
        <span class="cov0" title="0">expired := time.Now().Add(time.Hour * time.Duration(expired_jwt_int)).Unix()
        jwt_claim := jwt.NewWithClaims(jwt.SigningMethodHS256, 
        jwt.MapClaims{
                "id": id,
                "email": email,
                "role": role,
                "exp": expired,
        })
                
        secret_key := os.Getenv("SECRET_KEY")
        tokenString, err := jwt_claim.SignedString([]byte(secret_key))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error signed string jwt")
                return "", err
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}</pre>
		
		<pre class="file" id="file58" style="display: none">package utils

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

// Response represents the standard API response structure
type Response struct {
        Status  string      `json:"status" example:"success"`
        Message string      `json:"message" example:"Operation completed successfully"`
        Data    interface{} `json:"data,omitempty"`
}

// sendResponse is a helper function to send JSON responses
// code   : HTTP status code (200, 400, 404, etc.)
// status : "success" or "error"
// message: message to send
// data   : payload data, can be nil if not needed
func sendResponse(c echo.Context, code int, status string, message string, data interface{}) error <span class="cov0" title="0">{
        resp := map[string]interface{}{
                "status":  status,
                "message": message,
        }
        if data != nil </span><span class="cov0" title="0">{
                resp["data"] = data
        }</span>
        <span class="cov0" title="0">return c.JSON(code, resp)</span>
}

// SuccessResponse sends a standard success response with HTTP status 200 OK
// Example usage:
// return utils.SuccessResponse(c, "Data fetched successfully", data)
func SuccessResponse(c echo.Context, message string, data interface{}) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusOK, "success", message, data)
}</span>

// CreatedResponse sends a standard success response with HTTP status 201 Created
// Example usage:
// return utils.CreatedResponse(c, "User created successfully", user)
func CreatedResponse(c echo.Context, message string, data interface{}) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusCreated, "success", message, data)
}</span>

// NoContentResponse sends a standard success response with HTTP status 204 No Content
// Example usage:
// return utils.NoContentResponse(c)
func NoContentResponse(c echo.Context) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusNoContent, "success", "No Content", nil)
}</span>

// BadRequestResponse sends a standard error response with HTTP status 400 Bad Request
// Example usage:
// return utils.BadRequestResponse(c, "Invalid request parameters")
func BadRequestResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusBadRequest, "error", message, nil)
}</span>

// UnauthorizedResponse sends a standard error response with HTTP status 401 Unauthorized
// Example usage:
// return utils.UnauthorizedResponse(c, "Unauthorized access")
func UnauthorizedResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusUnauthorized, "error", message, nil)
}</span>

// ForbiddenResponse sends a standard error response with HTTP status 403 Forbidden
// Example usage:
// return utils.ForbiddenResponse(c, "Forbidden access")
func ForbiddenResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusForbidden, "error", message, nil)
}</span>

// NotFoundResponse sends a standard error response with HTTP status 404 Not Found
// Example usage:
// return utils.NotFoundResponse(c, "Resource not found")
func NotFoundResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusNotFound, "error", message, nil)
}</span>

// ConflictResponse sends a standard error response with HTTP status 409 Conflict
// Example usage:
// return utils.ConflictResponse(c, "Conflict occurred")
func ConflictResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusConflict, "error", message, nil)
}</span>

// UnprocessableEntityResponse sends a standard error response with HTTP status 422 Unprocessable Entity
// Example usage:
// return utils.UnprocessableEntityResponse(c, "Unprocessable entity")
func UnprocessableEntityResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusUnprocessableEntity, "error", message, nil)
}</span>

// InternalServerErrorResponse sends a standard error response with HTTP status 500 Internal Server Error
// Example usage:
// return utils.InternalServerErrorResponse(c, "Internal server error")
func InternalServerErrorResponse(c echo.Context, message string) error <span class="cov0" title="0">{
        return sendResponse(c, http.StatusInternalServerError, "error", message, nil)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
